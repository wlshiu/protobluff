{
    "docs": [
        {
            "location": "/", 
            "text": "protobluff is a modular Protocol Buffers implementation for C.", 
            "title": "About"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Installation\n\n\nBuilding from source\n\n\nprotobluff is built using \nAutotools\n and can be linked as a static or shared\nlibrary. It has no runtime dependencies and is fully self-contained, except for\nthe code generator which depends on the original Protocol Buffers runtime and\nis necessary to generate bindings from \n.proto\n schema files. If the original\nlibrary is not available, the generator is not built. The following commands\nbuild and install the protobluff library and code generator:\n\n\n./autogen.sh \n\n./configure \n\nmake \n\nmake \ntest\n \n\nmake install\n\n\n\n\nprotobluff should compile and run on all UNIX systems (including Linux and Mac\nOS) as it adheres to the C99 and C++98 standards, has no dependencies (except\nfor the code generator) and makes no system calls.\n\n\nAfter installing protobluff, the code generator can be used to generate\nbindings from \n.proto\n schema files to get started. See\n\nthis section\n for more information.\n\n\nAdditional options\n\n\nBy default, protobluff is compiled aggressively optimized with \n-O3\n and some\nfurther optimizations which make it nearly impossible to debug. If debugging\nis necessary, optimizations should be disabled. Stripped compilation will\nremove all symbols that are not defined in the public header files, allowing\nfurther optimizations. Enabling the coverage report is necessary to determine\nunit test coverage, and thus only needed during development.\n\n\n./configure\n  --disable-optimized \n# No optimizations (default: enabled)\n\n  --enable-stripped   \n# Strip internal symbols (default: disabled)\n\n  --enable-coverage   \n# Coverage report (default: disabled)\n\n\n\n\n\nUsing the code generator\n\n\nThe code generator is tightly integrated with the \nprotoc\n compiler toolchain\nincluded in the default Protocol Buffers distribution. Use the \nprotoc\n command\nto invoke the protobluff code generator through the \n--protobluff_out\n flag,\nto generate and write the respective \n.pb.h\n and \n.pb.c\n files to a specific\nlocation:\n\n\nprotoc --protobluff_out\n=\n. *.proto\n\n\n\n\nThe \n.pb.h\n header files contain the bindings, the \n.pb.c\n source files contain\nthe descriptor definitions and defaults which are referenced by the bindings.\nTherefore, the source files must be compiled together with your project.\n\n\nUsing the generated bindings\n\n\nHere's a \nusage example\n taken from the original\ndescription of the Google Protocol Buffers library and adapted to protobluff:\n\n\n/* Create an empty journal to assemble a new person message */\n\n\npb_journal_t\n \njournal\n \n=\n \npb_journal_create_empty\n();\n\n\n\n/* Create a person message */\n\n\npb_message_t\n \nperson\n \n=\n \nperson_create\n(\njournal\n);\n\n\n\n/* Define the values we want to set */\n\n\npb_string_t\n \nname\n   \n=\n \npb_string_init_from_chars\n(\nJohn Doe\n),\n\n            \nemail\n  \n=\n \npb_string_init_from_chars\n(\njdoe@example.com\n),\n\n            \nhome\n   \n=\n \npb_string_init_from_chars\n(\n+1-541-754-3010\n),\n\n            \nmobile\n \n=\n \npb_string_init_from_chars\n(\n+1-541-293-8228\n);\n\n\nint32_t\n     \nid\n     \n=\n \n1234\n;\n\n\n\n/* Set values on person message and check return codes */\n\n\npb_error_t\n \nerror\n \n=\n \nPB_ERROR_NONE\n;\n\n\ndo\n \n{\n\n  \nif\n \n((\nerror\n \n=\n \nperson_put_name\n(\nperson\n,\n \nname\n))\n \n||\n\n      \n(\nerror\n \n=\n \nperson_put_id\n(\nperson\n,\n \nid\n))\n \n||\n\n      \n(\nerror\n \n=\n \nperson_put_email\n(\nperson\n,\n \nemail\n)))\n\n    \nbreak\n;\n\n\n  \n/* Set home number */\n\n  \npb_message_t\n \nphone1\n \n=\n \nperson_create_phone\n(\nperson\n);\n\n  \nif\n \n(\n!\n(\nerror\n \n=\n \nperson_phonenumber_put_number\n(\nphone1\n,\n \nhome\n))\n \n\n      \n!\n(\nerror\n \n=\n \nperson_phonenumber_put_type_home\n(\nphone1\n)))\n \n{\n\n\n    \n/* Set mobile number */\n\n    \npb_message_t\n \nphone2\n \n=\n \nperson_create_phone\n(\nperson\n);\n\n    \nif\n \n(\n!\n(\nerror\n \n=\n \nperson_phonenumber_put_number\n(\nphone2\n,\n \nmobile\n))\n \n\n        \n!\n(\nerror\n \n=\n \nperson_phonenumber_put_type_mobile\n(\nphone2\n)))\n \n{\n\n\n      \n/* Dump the journal */\n\n      \npb_journal_dump\n(\njournal\n);\n\n\n      \n/* The encoded message can be accessed as follows */\n\n      \n// const uint8_t *data = pb_journal_data(\njournal);\n\n      \n// const size_t   size = pb_journal_size(\njournal);\n\n    \n}\n\n    \nperson_phonenumber_destroy\n(\nphone2\n);\n\n  \n}\n\n  \nperson_phonenumber_destroy\n(\nphone1\n);\n\n\n}\n \nwhile\n \n(\n0\n);\n\n\n\n/* Print error, if any */\n\n\nif\n \n(\nerror\n)\n\n  \nfprintf\n(\nstderr\n,\n \nERROR: %s\n\\n\n,\n \npb_error_string\n(\nerror\n));\n\n\n\n/* Cleanup and invalidate */\n\n\nperson_destroy\n(\nperson\n);\n\n\n\n/* Free all allocated memory and return */\n\n\npb_journal_destroy\n(\njournal\n);\n\n\n\n\n\nFirst the name, email and id of the person are written and then the two phone\nnumbers. However, the order of operations is not important. protobluff will\nensure that the fields are written in the right place, so we could also write\nthe name, then create the mobile phone number, add the email and id, change the\nphone number again and add the home phone number last. The result will be the\nsame. See the examples folder for more usage examples.\n\n\nLinking\n\n\nManually\n\n\nFor the generated bindings to function, your project must be linked against the\nprotobluff runtime. The recommended way is to dynamically link the shared\nlibrary. Therefore, the following compiler and linker flags must be obtained\nand added to your build toolchain:\n\n\npkg-config --cflags protobluff \n# Add output to compiler flags\n\npkg-config --libs   protobluff \n# Add output to linker flags\n\n\n\n\n\nSee \nthis section\n for more information on the available\nruntimes.\n\n\nAutotools\n\n\nIf you're using Autotools, the \nPKG_CHECK_MODULES\n macro will take care of the\nheavy lifting. Adding the following line to your \nconfigure.ac\n file will place\nthe compiler flags into the variable \nprotobluff_CFLAGS\n and the linker flags\ninto the variable \nprotobluff_LDFLAGS\n:\n\n\nPKG_CHECK_MODULES([protobluff],\n \n[protobluff])", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting-started/#installation", 
            "text": "", 
            "title": "Installation"
        }, 
        {
            "location": "/getting-started/#building-from-source", 
            "text": "protobluff is built using  Autotools  and can be linked as a static or shared\nlibrary. It has no runtime dependencies and is fully self-contained, except for\nthe code generator which depends on the original Protocol Buffers runtime and\nis necessary to generate bindings from  .proto  schema files. If the original\nlibrary is not available, the generator is not built. The following commands\nbuild and install the protobluff library and code generator:  ./autogen.sh  \n./configure  \nmake  \nmake  test   \nmake install  protobluff should compile and run on all UNIX systems (including Linux and Mac\nOS) as it adheres to the C99 and C++98 standards, has no dependencies (except\nfor the code generator) and makes no system calls.  After installing protobluff, the code generator can be used to generate\nbindings from  .proto  schema files to get started. See this section  for more information.", 
            "title": "Building from source"
        }, 
        {
            "location": "/getting-started/#additional-options", 
            "text": "By default, protobluff is compiled aggressively optimized with  -O3  and some\nfurther optimizations which make it nearly impossible to debug. If debugging\nis necessary, optimizations should be disabled. Stripped compilation will\nremove all symbols that are not defined in the public header files, allowing\nfurther optimizations. Enabling the coverage report is necessary to determine\nunit test coverage, and thus only needed during development.  ./configure\n  --disable-optimized  # No optimizations (default: enabled) \n  --enable-stripped    # Strip internal symbols (default: disabled) \n  --enable-coverage    # Coverage report (default: disabled)", 
            "title": "Additional options"
        }, 
        {
            "location": "/getting-started/#using-the-code-generator", 
            "text": "The code generator is tightly integrated with the  protoc  compiler toolchain\nincluded in the default Protocol Buffers distribution. Use the  protoc  command\nto invoke the protobluff code generator through the  --protobluff_out  flag,\nto generate and write the respective  .pb.h  and  .pb.c  files to a specific\nlocation:  protoc --protobluff_out = . *.proto  The  .pb.h  header files contain the bindings, the  .pb.c  source files contain\nthe descriptor definitions and defaults which are referenced by the bindings.\nTherefore, the source files must be compiled together with your project.", 
            "title": "Using the code generator"
        }, 
        {
            "location": "/getting-started/#using-the-generated-bindings", 
            "text": "Here's a  usage example  taken from the original\ndescription of the Google Protocol Buffers library and adapted to protobluff:  /* Create an empty journal to assemble a new person message */  pb_journal_t   journal   =   pb_journal_create_empty ();  /* Create a person message */  pb_message_t   person   =   person_create ( journal );  /* Define the values we want to set */  pb_string_t   name     =   pb_string_init_from_chars ( John Doe ), \n             email    =   pb_string_init_from_chars ( jdoe@example.com ), \n             home     =   pb_string_init_from_chars ( +1-541-754-3010 ), \n             mobile   =   pb_string_init_from_chars ( +1-541-293-8228 );  int32_t       id       =   1234 ;  /* Set values on person message and check return codes */  pb_error_t   error   =   PB_ERROR_NONE ;  do   { \n   if   (( error   =   person_put_name ( person ,   name ))   || \n       ( error   =   person_put_id ( person ,   id ))   || \n       ( error   =   person_put_email ( person ,   email ))) \n     break ; \n\n   /* Set home number */ \n   pb_message_t   phone1   =   person_create_phone ( person ); \n   if   ( ! ( error   =   person_phonenumber_put_number ( phone1 ,   home ))   \n       ! ( error   =   person_phonenumber_put_type_home ( phone1 )))   { \n\n     /* Set mobile number */ \n     pb_message_t   phone2   =   person_create_phone ( person ); \n     if   ( ! ( error   =   person_phonenumber_put_number ( phone2 ,   mobile ))   \n         ! ( error   =   person_phonenumber_put_type_mobile ( phone2 )))   { \n\n       /* Dump the journal */ \n       pb_journal_dump ( journal ); \n\n       /* The encoded message can be accessed as follows */ \n       // const uint8_t *data = pb_journal_data( journal); \n       // const size_t   size = pb_journal_size( journal); \n     } \n     person_phonenumber_destroy ( phone2 ); \n   } \n   person_phonenumber_destroy ( phone1 );  }   while   ( 0 );  /* Print error, if any */  if   ( error ) \n   fprintf ( stderr ,   ERROR: %s \\n ,   pb_error_string ( error ));  /* Cleanup and invalidate */  person_destroy ( person );  /* Free all allocated memory and return */  pb_journal_destroy ( journal );   First the name, email and id of the person are written and then the two phone\nnumbers. However, the order of operations is not important. protobluff will\nensure that the fields are written in the right place, so we could also write\nthe name, then create the mobile phone number, add the email and id, change the\nphone number again and add the home phone number last. The result will be the\nsame. See the examples folder for more usage examples.", 
            "title": "Using the generated bindings"
        }, 
        {
            "location": "/getting-started/#linking", 
            "text": "", 
            "title": "Linking"
        }, 
        {
            "location": "/getting-started/#manually", 
            "text": "For the generated bindings to function, your project must be linked against the\nprotobluff runtime. The recommended way is to dynamically link the shared\nlibrary. Therefore, the following compiler and linker flags must be obtained\nand added to your build toolchain:  pkg-config --cflags protobluff  # Add output to compiler flags \npkg-config --libs   protobluff  # Add output to linker flags   See  this section  for more information on the available\nruntimes.", 
            "title": "Manually"
        }, 
        {
            "location": "/getting-started/#autotools", 
            "text": "If you're using Autotools, the  PKG_CHECK_MODULES  macro will take care of the\nheavy lifting. Adding the following line to your  configure.ac  file will place\nthe compiler flags into the variable  protobluff_CFLAGS  and the linker flags\ninto the variable  protobluff_LDFLAGS :  PKG_CHECK_MODULES([protobluff],   [protobluff])", 
            "title": "Autotools"
        }, 
        {
            "location": "/design-rationale/", 
            "text": "The problem with Protocol Buffers\n\n\nProtocol Buffers\n is a language-neutral, platform-neutral and extensible\nmessage format developed by Google for serializing structured data. It uses\nschema files to describe the structure of messages, which are in turn used to\ngenerate language-specific bindings to automatically handle the decoding and\nencoding logic for the developer.\n\n\nIn most language-specific bindings, a Protocol Buffers message is entirely read\nand decoded to a native structure (like a \nstruct\n in C or a \nclass\n in C++)\nin a transparent manner. The problem is that this may involve a \nlarge number\nof allocations\n, especially for deeply nested and repeated messages. This is\nparticularly wasteful if only a few fields are needed in order to process a\nmessage, e.g. to decode the header for efficient routing or to update single\nfields/values within large messages.\n\n\nA different approach\n\n\nprotobluff follows a different approach: it omits the need to decode a\nProtocol Buffers message entirely in order to process it \u2013 \nall operations are\ndirectly carried out on the encoded message\n, so only specific parts/fields of\nthe encoded message need to be decoded. The same is true for encoding \u2013 only\nthe value that needs to be altered must be encoded, the rest of the message\nremains untouched.\n\n\nThe \ntechnical design goals\n behind protobluff are:\n\n\n\n\n\n\nErrors are handled gracefully, at all times\n. protobluff anticipates\n  errors like garbled data (regression via fuzzing tests) or out-of-memory\n  conditions and returns an error to the caller. All invariants are checked\n  with asserts, all runtime errors are checked during program execution. All\n  structures contain a valid flag/state. When passing an invalid structure to\n  a function, the program does not crash.\n\n\n\n\n\n\nStack-allocation is used wherever possible\n, so the programmer can decide\n  on where to use dynamic and static allocation. Memory management is\n  centralized, which significantly reduces programming errors.\n\n\n\n\n\n\nThe runtime should be extensible\n, i.e. it should be easy to write parsers\n  and printers for other formats like JSON or XML or other functionality on top\n  of the core library.\n\n\n\n\n\n\nFurthermore, protobluff comes with two \nruntimes\n: a \nlite\nruntime\n which enables easy and efficient stream-processing of Protocol\nBuffers messages via a callback-based decoder and an encoder, and a \nfull\nruntime\n which adds support for partial reads and writes of messages. New\nvalues can be read or written incrementally, memory management is centralized\nand handled by the underlying \njournal\n. If no\nalterations that change the size of the underlying journal are expected, the\njournal can be used in zero-copy mode, omitting all dynamic allocations.\n\n\nTrade-offs\n\n\nIn software development, everything is a trade-off. protobluff doesn't check\nthe encoded messages for validity, i.e. whether all required fields are set.\nThis should be done by the programmer using the validator explicitly, and is\nattributed to the fact that protobluff enables incremental reading and writing\nof messages, as discussed above. Moreover it is redundant when the programmer\nknows that a message is valid (e.g. when the messages comes from a database).\n\n\nThe lite runtime is efficient for decoding and encoding whole messages. The\nfull runtime should be used when only a few fields of a message need to be\nread or written. At the time of writing, protobluff is not very efficient when\ndecoding an encoding entire messages with the full runtime over and over. There\nare other libraries for that. However, as protobluff has a modular design, this\nfunctionality could be added if needed.", 
            "title": "Design rationale"
        }, 
        {
            "location": "/design-rationale/#the-problem-with-protocol-buffers", 
            "text": "Protocol Buffers  is a language-neutral, platform-neutral and extensible\nmessage format developed by Google for serializing structured data. It uses\nschema files to describe the structure of messages, which are in turn used to\ngenerate language-specific bindings to automatically handle the decoding and\nencoding logic for the developer.  In most language-specific bindings, a Protocol Buffers message is entirely read\nand decoded to a native structure (like a  struct  in C or a  class  in C++)\nin a transparent manner. The problem is that this may involve a  large number\nof allocations , especially for deeply nested and repeated messages. This is\nparticularly wasteful if only a few fields are needed in order to process a\nmessage, e.g. to decode the header for efficient routing or to update single\nfields/values within large messages.", 
            "title": "The problem with Protocol Buffers"
        }, 
        {
            "location": "/design-rationale/#a-different-approach", 
            "text": "protobluff follows a different approach: it omits the need to decode a\nProtocol Buffers message entirely in order to process it \u2013  all operations are\ndirectly carried out on the encoded message , so only specific parts/fields of\nthe encoded message need to be decoded. The same is true for encoding \u2013 only\nthe value that needs to be altered must be encoded, the rest of the message\nremains untouched.  The  technical design goals  behind protobluff are:    Errors are handled gracefully, at all times . protobluff anticipates\n  errors like garbled data (regression via fuzzing tests) or out-of-memory\n  conditions and returns an error to the caller. All invariants are checked\n  with asserts, all runtime errors are checked during program execution. All\n  structures contain a valid flag/state. When passing an invalid structure to\n  a function, the program does not crash.    Stack-allocation is used wherever possible , so the programmer can decide\n  on where to use dynamic and static allocation. Memory management is\n  centralized, which significantly reduces programming errors.    The runtime should be extensible , i.e. it should be easy to write parsers\n  and printers for other formats like JSON or XML or other functionality on top\n  of the core library.    Furthermore, protobluff comes with two  runtimes : a  lite\nruntime  which enables easy and efficient stream-processing of Protocol\nBuffers messages via a callback-based decoder and an encoder, and a  full\nruntime  which adds support for partial reads and writes of messages. New\nvalues can be read or written incrementally, memory management is centralized\nand handled by the underlying  journal . If no\nalterations that change the size of the underlying journal are expected, the\njournal can be used in zero-copy mode, omitting all dynamic allocations.", 
            "title": "A different approach"
        }, 
        {
            "location": "/design-rationale/#trade-offs", 
            "text": "In software development, everything is a trade-off. protobluff doesn't check\nthe encoded messages for validity, i.e. whether all required fields are set.\nThis should be done by the programmer using the validator explicitly, and is\nattributed to the fact that protobluff enables incremental reading and writing\nof messages, as discussed above. Moreover it is redundant when the programmer\nknows that a message is valid (e.g. when the messages comes from a database).  The lite runtime is efficient for decoding and encoding whole messages. The\nfull runtime should be used when only a few fields of a message need to be\nread or written. At the time of writing, protobluff is not very efficient when\ndecoding an encoding entire messages with the full runtime over and over. There\nare other libraries for that. However, as protobluff has a modular design, this\nfunctionality could be added if needed.", 
            "title": "Trade-offs"
        }, 
        {
            "location": "/similar-projects/", 
            "text": "Overview\n\n\nprotobluff is not the only C implementation for Protocol Buffers in the world,\nbut it's actually one of the more recent ones. It has a different approach for\nhandling messages than other libraries, like already described in the\n\ndesignal rationale\n.\n\n\nThis document compares protobluff to other Protocol Buffers implementations\nfor the C language, in particular \nprotobuf-c\n, \nnanopb\n, \nlwpb\n and\n\npbc\n. Compared are only libraries that are not exclusively targeted at\nmicrocontrollers, but are designed for 32- and 64-bit systems.\n\n\nFeature comparison\n\n\nproto2\n\n\nprotobluff implements all features of the Protocol Buffers specification\nversion 2 (known as proto2), except groups and generic services which are both\ndeprecated. However, as Google is pushing out \ngRPC\n, there may be a\ngRPC-based service implementation in form of a plugin in the future. Below is\na table showing the supported features of protobluff next to other Protocol\nBuffers libraries for C:\n\n\n\n\n\n\n\n\nFeature / Implementation\n\n\nprotobluff\n\n\nprotobuf-c\n\n\nnanopb\n\n\nlwpb\n\n\npbc\n\n\n\n\n\n\n\n\n\n\nMessage types\n\n\nyes\n\n\nyes\n\n\nyes\n\n\nyes\n\n\nyes\n\n\n\n\n\n\nNested message types\n\n\nyes\n\n\nyes\n\n\nyes\n\n\nyes\n\n\nyes\n\n\n\n\n\n\nCyclic message types\n\n\nyes\n\n\nyes\n\n\npartial\n\n\nyes\n\n\nyes\n\n\n\n\n\n\nScalar types\n\n\nyes\n\n\nyes\n\n\nyes\n\n\nyes\n\n\nyes\n\n\n\n\n\n\nDefault values\n\n\nyes\n\n\nyes\n\n\nyes\n\n\nyes\n\n\nyes\n\n\n\n\n\n\nEnumerations\n\n\nyes\n\n\nyes\n\n\nyes\n\n\nyes\n\n\nyes\n\n\n\n\n\n\nExtensions\n\n\nyes\n\n\n-\n\n\nyes\n\n\n-\n\n\nyes\n\n\n\n\n\n\nOneofs\n\n\nyes\n\n\nyes\n\n\nyes\n\n\n-\n\n\n-\n\n\n\n\n\n\nPackages\n\n\nyes\n\n\nyes\n\n\nyes\n\n\nyes\n\n\nyes\n\n\n\n\n\n\nPacked option\n\n\nyes\n\n\nyes\n\n\nyes\n\n\nyes\n\n\nyes\n\n\n\n\n\n\nDeprecations\n\n\nyes\n\n\npartial\n\n\n-\n\n\n-\n\n\n-\n\n\n\n\n\n\n\n\nIn respect to the deprecation of generic services and groups, protobluff is the\nonly library which is feature complete. \nnanopb\n is pretty close: it only\nmisses deprecations and is inconvenient for working with cyclic messages.\nFurthermore, it's targeted at microcontrollers. \nprotobuf-c\n doesn't support\nextensions and supports deprecations for fields only. \nlwpb\n and \npbc\n seem\ninactive, as they don't support oneofs, a feature introduced in version 2.6.\n\n\nBoth, protobuf-c and lwpb provide a custom service implementation. However, the\nbenefit is questionable, because the way messages are handled within a service\nmay be highly application-dependent. Therefore, the solution proposed by both\nlibraries may or may not be a good fit for your application. This is the reason\nwhy Google deprecated generic services and open sourced gRPC to provide a\nstandard protocol for service interaction and integration.\n\n\nproto3\n\n\nThe newest version of the Protocol Buffers specification is\n\nversion 3\n (known as proto3) which is\nwire-compatible with proto2. protobluff is basically compatible with proto3 \u2013\nit will compile with the proto3 runtime, but it is not yet optimized for the\nnew syntax.\n\n\nThe main features that need to be implemented for full proto3 support are\nmaps and the \nAny\n type as a replacement for extensions, as well as some\nhelper functions for working with the new set of default types and maybe the\nnew JSON-mapping. However, the last two are of lower priority.\n\n\nAt the time of writing, none of the aforementioned alternative implementations\nsupports proto3 yet.", 
            "title": "Similar projects"
        }, 
        {
            "location": "/similar-projects/#overview", 
            "text": "protobluff is not the only C implementation for Protocol Buffers in the world,\nbut it's actually one of the more recent ones. It has a different approach for\nhandling messages than other libraries, like already described in the designal rationale .  This document compares protobluff to other Protocol Buffers implementations\nfor the C language, in particular  protobuf-c ,  nanopb ,  lwpb  and pbc . Compared are only libraries that are not exclusively targeted at\nmicrocontrollers, but are designed for 32- and 64-bit systems.", 
            "title": "Overview"
        }, 
        {
            "location": "/similar-projects/#feature-comparison", 
            "text": "", 
            "title": "Feature comparison"
        }, 
        {
            "location": "/similar-projects/#proto2", 
            "text": "protobluff implements all features of the Protocol Buffers specification\nversion 2 (known as proto2), except groups and generic services which are both\ndeprecated. However, as Google is pushing out  gRPC , there may be a\ngRPC-based service implementation in form of a plugin in the future. Below is\na table showing the supported features of protobluff next to other Protocol\nBuffers libraries for C:     Feature / Implementation  protobluff  protobuf-c  nanopb  lwpb  pbc      Message types  yes  yes  yes  yes  yes    Nested message types  yes  yes  yes  yes  yes    Cyclic message types  yes  yes  partial  yes  yes    Scalar types  yes  yes  yes  yes  yes    Default values  yes  yes  yes  yes  yes    Enumerations  yes  yes  yes  yes  yes    Extensions  yes  -  yes  -  yes    Oneofs  yes  yes  yes  -  -    Packages  yes  yes  yes  yes  yes    Packed option  yes  yes  yes  yes  yes    Deprecations  yes  partial  -  -  -     In respect to the deprecation of generic services and groups, protobluff is the\nonly library which is feature complete.  nanopb  is pretty close: it only\nmisses deprecations and is inconvenient for working with cyclic messages.\nFurthermore, it's targeted at microcontrollers.  protobuf-c  doesn't support\nextensions and supports deprecations for fields only.  lwpb  and  pbc  seem\ninactive, as they don't support oneofs, a feature introduced in version 2.6.  Both, protobuf-c and lwpb provide a custom service implementation. However, the\nbenefit is questionable, because the way messages are handled within a service\nmay be highly application-dependent. Therefore, the solution proposed by both\nlibraries may or may not be a good fit for your application. This is the reason\nwhy Google deprecated generic services and open sourced gRPC to provide a\nstandard protocol for service interaction and integration.", 
            "title": "proto2"
        }, 
        {
            "location": "/similar-projects/#proto3", 
            "text": "The newest version of the Protocol Buffers specification is version 3  (known as proto3) which is\nwire-compatible with proto2. protobluff is basically compatible with proto3 \u2013\nit will compile with the proto3 runtime, but it is not yet optimized for the\nnew syntax.  The main features that need to be implemented for full proto3 support are\nmaps and the  Any  type as a replacement for extensions, as well as some\nhelper functions for working with the new set of default types and maybe the\nnew JSON-mapping. However, the last two are of lower priority.  At the time of writing, none of the aforementioned alternative implementations\nsupports proto3 yet.", 
            "title": "proto3"
        }, 
        {
            "location": "/guide/runtimes/", 
            "text": "Full runtime\n\n\nOverview\n\n\nThe full runtime includes the logic of the \nlite runtime\n and\nadds support for partial reads and writes of messages. It weighs around 41kb\n(\n-O3\n, stripped) or respectively 32kb (\n-Os\n, stripped) when compiled on\nx86_64.\n\n\nLinking\n\n\nThe canonical name of the full runtime is \nprotobluff\n. The following\ncompiler and linker flags must be obtained and added to your build toolchain:\n\n\npkg-config --cflags protobluff \n# Add output to compiler flags\n\npkg-config --libs   protobluff \n# Add output to linker flags\n\n\n\n\n\nWith \nAutotools\n, the \nPKG_CHECK_MODULES\n macro can be used within your\n\nconfigure.ac\n, which will check for the full runtime and define the flags\n\nprotobluff_CFLAGS\n and \nprotobluff_LDFLAGS\n:\n\n\nPKG_CHECK_MODULES([protobluff],\n \n[protobluff])\n\n\n\n\n\nUsage\n\n\nHere's a \nusage example\n taken from the original\ndescription of the Google Protocol Buffers library and adapted to protobluff's\nfull runtime:\n\n\n/* Create an empty journal to assemble a new person message */\n\n\npb_journal_t\n \njournal\n \n=\n \npb_journal_create_empty\n();\n\n\n\n/* Create a person message */\n\n\npb_message_t\n \nperson\n \n=\n \nperson_create\n(\njournal\n);\n\n\n\n/* Define the values we want to set */\n\n\npb_string_t\n \nname\n   \n=\n \npb_string_init_from_chars\n(\nJohn Doe\n),\n\n            \nemail\n  \n=\n \npb_string_init_from_chars\n(\njdoe@example.com\n),\n\n            \nhome\n   \n=\n \npb_string_init_from_chars\n(\n+1-541-754-3010\n),\n\n            \nmobile\n \n=\n \npb_string_init_from_chars\n(\n+1-541-293-8228\n);\n\n\nint32_t\n     \nid\n     \n=\n \n1234\n;\n\n\n\n/* Set values on person message and check return codes */\n\n\npb_error_t\n \nerror\n \n=\n \nPB_ERROR_NONE\n;\n\n\ndo\n \n{\n\n  \nif\n \n((\nerror\n \n=\n \nperson_put_name\n(\nperson\n,\n \nname\n))\n \n||\n\n      \n(\nerror\n \n=\n \nperson_put_id\n(\nperson\n,\n \nid\n))\n \n||\n\n      \n(\nerror\n \n=\n \nperson_put_email\n(\nperson\n,\n \nemail\n)))\n\n    \nbreak\n;\n\n\n  \n/* Set home number */\n\n  \npb_message_t\n \nphone1\n \n=\n \nperson_create_phone\n(\nperson\n);\n\n  \nif\n \n(\n!\n(\nerror\n \n=\n \nperson_phonenumber_put_number\n(\nphone1\n,\n \nhome\n))\n \n\n      \n!\n(\nerror\n \n=\n \nperson_phonenumber_put_type_home\n(\nphone1\n)))\n \n{\n\n\n    \n/* Set mobile number */\n\n    \npb_message_t\n \nphone2\n \n=\n \nperson_create_phone\n(\nperson\n);\n\n    \nif\n \n(\n!\n(\nerror\n \n=\n \nperson_phonenumber_put_number\n(\nphone2\n,\n \nmobile\n))\n \n\n        \n!\n(\nerror\n \n=\n \nperson_phonenumber_put_type_mobile\n(\nphone2\n)))\n \n{\n\n\n      \n/* Dump the journal */\n\n      \npb_journal_dump\n(\njournal\n);\n\n\n      \n/* The encoded message can be accessed as follows */\n\n      \n// const uint8_t *data = pb_journal_data(\njournal);\n\n      \n// const size_t   size = pb_journal_size(\njournal);\n\n    \n}\n\n    \nperson_phonenumber_destroy\n(\nphone2\n);\n\n  \n}\n\n  \nperson_phonenumber_destroy\n(\nphone1\n);\n\n\n}\n \nwhile\n \n(\n0\n);\n\n\n\n/* Print error, if any */\n\n\nif\n \n(\nerror\n)\n\n  \nfprintf\n(\nstderr\n,\n \nERROR: %s\n\\n\n,\n \npb_error_string\n(\nerror\n));\n\n\n\n/* Cleanup and invalidate */\n\n\nperson_destroy\n(\nperson\n);\n\n\n\n/* Free all allocated memory and return */\n\n\npb_journal_destroy\n(\njournal\n);\n\n\n\n\n\nLite runtime\n\n\nOverview\n\n\nThe lite runtime includes the bare minimum of logic to decode and encode\nProtocol Buffers messages. It's most suitable for environments with constrained\nresources, as it only weighs around 17kb (\n-O3\n, stripped) or respectively 13kb\n(\n-Os\n, stripped) when compiled on x86_64. Though not being the highest\npriority task on the list, compatibility with embedded environments is planned.\n\n\nThe lite runtime enables the decoding and encoding of whole messages. However,\nit has no explicit support for oneofs and message validation.\n\n\nLinking\n\n\nThe canonical name of the lite runtime is \nprotobluff-lite\n. The following\ncompiler and linker flags must be obtained and added to your build toolchain:\n\n\npkg-config --cflags protobluff-lite \n# Add output to compiler flags\n\npkg-config --libs   protobluff-lite \n# Add output to linker flags\n\n\n\n\n\nWith \nAutotools\n, the \nPKG_CHECK_MODULES\n macro can be used within your\n\nconfigure.ac\n, which will check for the lite runtime and define the flags\n\nprotobluff_CFLAGS\n and \nprotobluff_LDFLAGS\n:\n\n\nPKG_CHECK_MODULES([protobluff],\n \n[protobluff-lite])\n\n\n\n\n\nUsage\n\n\nHere's a \nusage example\n taken from the original\ndescription of the Google Protocol Buffers library and adapted to protobluff's\nlite runtime:\n\n\n/* Create a person encoder */\n\n\npb_encoder_t\n \nperson\n \n=\n \nperson_encoder_create\n();\n\n\n\n/* Define the values we want to set */\n\n\npb_string_t\n \nname\n   \n=\n \npb_string_init_from_chars\n(\nJohn Doe\n),\n\n            \nemail\n  \n=\n \npb_string_init_from_chars\n(\njdoe@example.com\n),\n\n            \nhome\n   \n=\n \npb_string_init_from_chars\n(\n+1-541-754-3010\n),\n\n            \nmobile\n \n=\n \npb_string_init_from_chars\n(\n+1-541-293-8228\n);\n\n\nint32_t\n     \nid\n     \n=\n \n1234\n;\n\n\n\n/* Encode values for person message and check return codes */\n\n\npb_error_t\n \nerror\n \n=\n \nPB_ERROR_NONE\n;\n\n\ndo\n \n{\n\n  \nif\n \n((\nerror\n \n=\n \nperson_encode_name\n(\nperson\n,\n \nname\n))\n \n||\n\n      \n(\nerror\n \n=\n \nperson_encode_id\n(\nperson\n,\n \nid\n))\n \n||\n\n      \n(\nerror\n \n=\n \nperson_encode_email\n(\nperson\n,\n \nemail\n)))\n\n    \nbreak\n;\n\n\n  \n/* Set home and mobile number */\n\n  \npb_encoder_t\n \nphone\n[]\n \n=\n \n{\n\n    \nperson_phonenumber_encoder_create\n(),\n\n    \nperson_phonenumber_encoder_create\n()\n\n  \n};\n\n  \nif\n \n(\n!\n(\nerror\n \n=\n \nperson_phonenumber_encode_number\n(\n(\nphone\n[\n0\n]),\n \nhome\n))\n \n\n      \n!\n(\nerror\n \n=\n \nperson_phonenumber_encode_type_home\n(\n(\nphone\n[\n0\n])))\n \n\n      \n!\n(\nerror\n \n=\n \nperson_phonenumber_encode_number\n(\n(\nphone\n[\n1\n]),\n \nmobile\n))\n \n\n      \n!\n(\nerror\n \n=\n \nperson_phonenumber_encode_type_mobile\n(\n(\nphone\n[\n1\n])))\n \n\n      \n!\n(\nerror\n \n=\n \nperson_encode_phone\n(\nperson\n,\n \nphone\n,\n \n2\n)))\n \n{\n\n\n    \n/* Dump the internal buffer */\n\n    \nconst\n \npb_buffer_t\n \n*\nbuffer\n \n=\n \npb_encoder_buffer\n(\nperson\n);\n\n    \npb_buffer_dump\n(\nbuffer\n);\n\n\n    \n/* The encoded message can be accessed as follows */\n\n    \n// const uint8_t *data = pb_buffer_data(buffer);\n\n    \n// const size_t   size = pb_buffer_size(buffer);\n\n  \n}\n\n  \nperson_phonenumber_encoder_destroy\n(\n(\nphone\n[\n0\n]));\n\n  \nperson_phonenumber_encoder_destroy\n(\n(\nphone\n[\n1\n]));\n\n\n}\n \nwhile\n \n(\n0\n);\n\n\n\n/* Print error, if any */\n\n\nif\n \n(\nerror\n)\n\n  \nfprintf\n(\nstderr\n,\n \nERROR: %s\n\\n\n,\n \npb_error_string\n(\nerror\n));\n\n\n\n/* Free all allocated memory and return */\n\n\nperson_encoder_destroy\n(\nperson\n);", 
            "title": "Choosing a runtime"
        }, 
        {
            "location": "/guide/runtimes/#full-runtime", 
            "text": "", 
            "title": "Full runtime"
        }, 
        {
            "location": "/guide/runtimes/#overview", 
            "text": "The full runtime includes the logic of the  lite runtime  and\nadds support for partial reads and writes of messages. It weighs around 41kb\n( -O3 , stripped) or respectively 32kb ( -Os , stripped) when compiled on\nx86_64.", 
            "title": "Overview"
        }, 
        {
            "location": "/guide/runtimes/#linking", 
            "text": "The canonical name of the full runtime is  protobluff . The following\ncompiler and linker flags must be obtained and added to your build toolchain:  pkg-config --cflags protobluff  # Add output to compiler flags \npkg-config --libs   protobluff  # Add output to linker flags   With  Autotools , the  PKG_CHECK_MODULES  macro can be used within your configure.ac , which will check for the full runtime and define the flags protobluff_CFLAGS  and  protobluff_LDFLAGS :  PKG_CHECK_MODULES([protobluff],   [protobluff])", 
            "title": "Linking"
        }, 
        {
            "location": "/guide/runtimes/#usage", 
            "text": "Here's a  usage example  taken from the original\ndescription of the Google Protocol Buffers library and adapted to protobluff's\nfull runtime:  /* Create an empty journal to assemble a new person message */  pb_journal_t   journal   =   pb_journal_create_empty ();  /* Create a person message */  pb_message_t   person   =   person_create ( journal );  /* Define the values we want to set */  pb_string_t   name     =   pb_string_init_from_chars ( John Doe ), \n             email    =   pb_string_init_from_chars ( jdoe@example.com ), \n             home     =   pb_string_init_from_chars ( +1-541-754-3010 ), \n             mobile   =   pb_string_init_from_chars ( +1-541-293-8228 );  int32_t       id       =   1234 ;  /* Set values on person message and check return codes */  pb_error_t   error   =   PB_ERROR_NONE ;  do   { \n   if   (( error   =   person_put_name ( person ,   name ))   || \n       ( error   =   person_put_id ( person ,   id ))   || \n       ( error   =   person_put_email ( person ,   email ))) \n     break ; \n\n   /* Set home number */ \n   pb_message_t   phone1   =   person_create_phone ( person ); \n   if   ( ! ( error   =   person_phonenumber_put_number ( phone1 ,   home ))   \n       ! ( error   =   person_phonenumber_put_type_home ( phone1 )))   { \n\n     /* Set mobile number */ \n     pb_message_t   phone2   =   person_create_phone ( person ); \n     if   ( ! ( error   =   person_phonenumber_put_number ( phone2 ,   mobile ))   \n         ! ( error   =   person_phonenumber_put_type_mobile ( phone2 )))   { \n\n       /* Dump the journal */ \n       pb_journal_dump ( journal ); \n\n       /* The encoded message can be accessed as follows */ \n       // const uint8_t *data = pb_journal_data( journal); \n       // const size_t   size = pb_journal_size( journal); \n     } \n     person_phonenumber_destroy ( phone2 ); \n   } \n   person_phonenumber_destroy ( phone1 );  }   while   ( 0 );  /* Print error, if any */  if   ( error ) \n   fprintf ( stderr ,   ERROR: %s \\n ,   pb_error_string ( error ));  /* Cleanup and invalidate */  person_destroy ( person );  /* Free all allocated memory and return */  pb_journal_destroy ( journal );", 
            "title": "Usage"
        }, 
        {
            "location": "/guide/runtimes/#lite-runtime", 
            "text": "", 
            "title": "Lite runtime"
        }, 
        {
            "location": "/guide/runtimes/#overview_1", 
            "text": "The lite runtime includes the bare minimum of logic to decode and encode\nProtocol Buffers messages. It's most suitable for environments with constrained\nresources, as it only weighs around 17kb ( -O3 , stripped) or respectively 13kb\n( -Os , stripped) when compiled on x86_64. Though not being the highest\npriority task on the list, compatibility with embedded environments is planned.  The lite runtime enables the decoding and encoding of whole messages. However,\nit has no explicit support for oneofs and message validation.", 
            "title": "Overview"
        }, 
        {
            "location": "/guide/runtimes/#linking_1", 
            "text": "The canonical name of the lite runtime is  protobluff-lite . The following\ncompiler and linker flags must be obtained and added to your build toolchain:  pkg-config --cflags protobluff-lite  # Add output to compiler flags \npkg-config --libs   protobluff-lite  # Add output to linker flags   With  Autotools , the  PKG_CHECK_MODULES  macro can be used within your configure.ac , which will check for the lite runtime and define the flags protobluff_CFLAGS  and  protobluff_LDFLAGS :  PKG_CHECK_MODULES([protobluff],   [protobluff-lite])", 
            "title": "Linking"
        }, 
        {
            "location": "/guide/runtimes/#usage_1", 
            "text": "Here's a  usage example  taken from the original\ndescription of the Google Protocol Buffers library and adapted to protobluff's\nlite runtime:  /* Create a person encoder */  pb_encoder_t   person   =   person_encoder_create ();  /* Define the values we want to set */  pb_string_t   name     =   pb_string_init_from_chars ( John Doe ), \n             email    =   pb_string_init_from_chars ( jdoe@example.com ), \n             home     =   pb_string_init_from_chars ( +1-541-754-3010 ), \n             mobile   =   pb_string_init_from_chars ( +1-541-293-8228 );  int32_t       id       =   1234 ;  /* Encode values for person message and check return codes */  pb_error_t   error   =   PB_ERROR_NONE ;  do   { \n   if   (( error   =   person_encode_name ( person ,   name ))   || \n       ( error   =   person_encode_id ( person ,   id ))   || \n       ( error   =   person_encode_email ( person ,   email ))) \n     break ; \n\n   /* Set home and mobile number */ \n   pb_encoder_t   phone []   =   { \n     person_phonenumber_encoder_create (), \n     person_phonenumber_encoder_create () \n   }; \n   if   ( ! ( error   =   person_phonenumber_encode_number ( ( phone [ 0 ]),   home ))   \n       ! ( error   =   person_phonenumber_encode_type_home ( ( phone [ 0 ])))   \n       ! ( error   =   person_phonenumber_encode_number ( ( phone [ 1 ]),   mobile ))   \n       ! ( error   =   person_phonenumber_encode_type_mobile ( ( phone [ 1 ])))   \n       ! ( error   =   person_encode_phone ( person ,   phone ,   2 )))   { \n\n     /* Dump the internal buffer */ \n     const   pb_buffer_t   * buffer   =   pb_encoder_buffer ( person ); \n     pb_buffer_dump ( buffer ); \n\n     /* The encoded message can be accessed as follows */ \n     // const uint8_t *data = pb_buffer_data(buffer); \n     // const size_t   size = pb_buffer_size(buffer); \n   } \n   person_phonenumber_encoder_destroy ( ( phone [ 0 ])); \n   person_phonenumber_encoder_destroy ( ( phone [ 1 ]));  }   while   ( 0 );  /* Print error, if any */  if   ( error ) \n   fprintf ( stderr ,   ERROR: %s \\n ,   pb_error_string ( error ));  /* Free all allocated memory and return */  person_encoder_destroy ( person );", 
            "title": "Usage"
        }, 
        {
            "location": "/guide/buffers-and-journals/", 
            "text": "Overview\n\n\nprotobluff directly operates on the wire representation of a message, so reads\nand writes can be carried out without decoding and re-encoding the whole\nmessage.\n\n\nIn order to work with a message, the raw data must be wrapped inside a buffer\nfor the lite runtime and inside a journal for the full runtime. Buffers are the\nsingle point of allocation inside protobluff, which means the developer is only\nresponsible for creating and destroying the buffer (or respectively journal).\nThis mitigates the pain of memory management, which is common in some other\nProtocol Buffers implementations for the C language. All other structures\ninside protobluff are allocated on the stack.\n\n\nJournals are just buffers on steroids - they track every change made. This is\ncrucial when working with more than one pointer (field, submessage or cursor)\nto a message, especially in the case of partial updates, as those pointers may\nget invalidated by those updates, e.g. if field offsets change.\n\n\npb_buffer_t\n \nbuffer\n \n=\n \npb_buffer_create_empty\n();\n\n\nif\n \n(\n!\npb_buffer_valid\n(\nbuffer\n))\n \n{\n\n  \nfprintf\n(\nstderr\n,\n \nError: %s\n,\n \npb_error_string\n(\npb_buffer_error\n(\nbuffer\n)));\n\n\n}\n \nelse\n \n{\n\n  \n...\n\n  \nconst\n \nuint8_t\n \n*\ndata\n \n=\n \npb_buffer_data\n(\nbuffer\n);\n\n  \nconst\n \nsize_t\n   \nsize\n \n=\n \npb_buffer_size\n(\nbuffer\n);\n\n  \n...\n\n\n}\n\n\npb_buffer_destroy\n(\nbuffer\n);\n\n\n\n\n\nBuffers and journals share the same interface, as journals are just wrappers\naround buffers, so within the following function calls, \nbuffer\n may be\nsubstituted for \njournal\n to get the equivalent function call.\n\n\nCreating a buffer\n\n\nAn encoded Protocol Buffers message is represented as an array of bytes of\na certain size:\n\n\nuint8_t\n \ndata\n[]\n \n=\n \n...\n\n\nsize_t\n  \nsize\n   \n=\n \n...\n\n\n\n\n\nIn order to decode and work with this Protocol Buffers message, a protobluff\nbuffer (or respectively journal) must be created with the encoded message's raw\ndata and size:\n\n\npb_buffer_t\n \nbuffer\n \n=\n \npb_buffer_create\n(\ndata\n,\n \nsize\n);\n\n\n\n\n\nprotobluff does not take ownership of the original buffer, but copies the data\nto an internally allocated buffer. This is necessary, because writes to fields\nof the message may alter the length of the externally allocated array of bytes.\n\n\nCreating a zero-copy buffer\n\n\nIf the original data is not expected to be altered, a zero-copy buffer can be\ncreated. protobluff will assume that the externally allocated buffer is not\nfreed during operations:\n\n\npb_buffer_t\n \nbuffer\n \n=\n \npb_buffer_create_zero_copy\n(\ndata\n,\n \nsize\n);\n\n\n\n\n\nAll operations that do not impact the length of the buffer will succeed and\nchange the original encoded Protocol Buffers message in-place, e.g. all read\noperations and write operations that only change the contents, but not the\nlength of a field. Alterations that change the length of the buffer will fail\nand return \nPB_ERROR_ALLOC\n, as protobluff will not (and cannot) resize the\nexternally allocated buffer.\n\n\nCreating an empty buffer\n\n\nIf no buffer data is given, e.g. when a new Protocol Buffers message should be\nconstructed from scratch, an empty buffer can be created:\n\n\npb_buffer_t\n \nbuffer\n \n=\n \npb_buffer_create_empty\n();\n\n\n\n\n\nFreeing a buffer\n\n\nWhen finished working with the underlying message, the buffer must be\ndestroyed explicitly, so the internally allocated space can be freed:\n\n\npb_buffer_destroy\n(\nbuffer\n);\n\n\n\n\n\nZero-copy buffers should also always be destroyed for reasons of consistency,\neven if, at the time of writing, no internal allocations are taking place, as\nthis may be subject to change in the future.\n\n\nError handling\n\n\nAfar from zero-copy buffers, creation of regular buffers can theoretically\nfail due to an out-of-memory condition (\nENOMEM\n). protobluff is designed to\nfully recover from such conditions, passing the error back to the caller after\ncleaning up any prior allocations. For this reason, the caller should always\nvalidate whether buffer creation was successful:\n\n\npb_buffer_t\n \nbuffer\n \n=\n \npb_buffer_create_empty\n();\n\n\nif\n \n(\n!\npb_buffer_valid\n(\nbuffer\n))\n\n  \nfprintf\n(\nstderr\n,\n \nError: %s\n,\n \npb_error_string\n(\npb_buffer_error\n(\nbuffer\n)));\n\n\n\n\n\nIf the caller doesn't validate the buffer after creation and the buffer is\nnot valid, all subsequent calls on messages, cursors and fields will return\nerrors (see the section on \nerror handling\n for more\ndetails).\n\n\nAccessors\n\n\nThe buffer may not be altered directly, only by invoking the generated Protocol\nBuffer message accessors or the low-level interface. The raw data and size\nunderlying the buffer can be extracted with the following methods at any time:\n\n\nconst\n \nuint8_t\n \n*\ndata\n \n=\n \npb_buffer_data\n(\nbuffer\n);\n\n\nconst\n \nsize_t\n   \nsize\n \n=\n \npb_buffer_size\n(\nbuffer\n);\n\n\n\n\n\nCustom allocators\n\n\nprotobluff is designed to allow \ncustom allocator\n\nimplementations, facilitating a more fine grained control of how memory is\nlayed out. The default allocator is just a wrapper around the POSIX functions\n\nmalloc\n, \nrealloc\n and \nfree\n. Alternative implementations may yield better\nperformance in specific cases, like chunk allocators or fixed-size allocators.\nA buffer can be easily created together with a custom allocator:\n\n\npb_buffer_t\n \nbuffer\n \n=\n \npb_buffer_create_with_allocator\n(\nallocator\n,\n \ndata\n,\n \nsize\n);\n\n\n\n\n\nThe same holds for an empty buffer:\n\n\npb_buffer_t\n \nbuffer\n \n=\n \npb_buffer_create_empty_with_allocator\n(\nallocator\n);\n\n\n\n\n\nFor guidance on this topic, see the documentation on\n\ncustom allocators\n.", 
            "title": "Buffers and journals"
        }, 
        {
            "location": "/guide/buffers-and-journals/#overview", 
            "text": "protobluff directly operates on the wire representation of a message, so reads\nand writes can be carried out without decoding and re-encoding the whole\nmessage.  In order to work with a message, the raw data must be wrapped inside a buffer\nfor the lite runtime and inside a journal for the full runtime. Buffers are the\nsingle point of allocation inside protobluff, which means the developer is only\nresponsible for creating and destroying the buffer (or respectively journal).\nThis mitigates the pain of memory management, which is common in some other\nProtocol Buffers implementations for the C language. All other structures\ninside protobluff are allocated on the stack.  Journals are just buffers on steroids - they track every change made. This is\ncrucial when working with more than one pointer (field, submessage or cursor)\nto a message, especially in the case of partial updates, as those pointers may\nget invalidated by those updates, e.g. if field offsets change.  pb_buffer_t   buffer   =   pb_buffer_create_empty ();  if   ( ! pb_buffer_valid ( buffer ))   { \n   fprintf ( stderr ,   Error: %s ,   pb_error_string ( pb_buffer_error ( buffer )));  }   else   { \n   ... \n   const   uint8_t   * data   =   pb_buffer_data ( buffer ); \n   const   size_t     size   =   pb_buffer_size ( buffer ); \n   ...  }  pb_buffer_destroy ( buffer );   Buffers and journals share the same interface, as journals are just wrappers\naround buffers, so within the following function calls,  buffer  may be\nsubstituted for  journal  to get the equivalent function call.", 
            "title": "Overview"
        }, 
        {
            "location": "/guide/buffers-and-journals/#creating-a-buffer", 
            "text": "An encoded Protocol Buffers message is represented as an array of bytes of\na certain size:  uint8_t   data []   =   ...  size_t    size     =   ...   In order to decode and work with this Protocol Buffers message, a protobluff\nbuffer (or respectively journal) must be created with the encoded message's raw\ndata and size:  pb_buffer_t   buffer   =   pb_buffer_create ( data ,   size );   protobluff does not take ownership of the original buffer, but copies the data\nto an internally allocated buffer. This is necessary, because writes to fields\nof the message may alter the length of the externally allocated array of bytes.", 
            "title": "Creating a buffer"
        }, 
        {
            "location": "/guide/buffers-and-journals/#creating-a-zero-copy-buffer", 
            "text": "If the original data is not expected to be altered, a zero-copy buffer can be\ncreated. protobluff will assume that the externally allocated buffer is not\nfreed during operations:  pb_buffer_t   buffer   =   pb_buffer_create_zero_copy ( data ,   size );   All operations that do not impact the length of the buffer will succeed and\nchange the original encoded Protocol Buffers message in-place, e.g. all read\noperations and write operations that only change the contents, but not the\nlength of a field. Alterations that change the length of the buffer will fail\nand return  PB_ERROR_ALLOC , as protobluff will not (and cannot) resize the\nexternally allocated buffer.", 
            "title": "Creating a zero-copy buffer"
        }, 
        {
            "location": "/guide/buffers-and-journals/#creating-an-empty-buffer", 
            "text": "If no buffer data is given, e.g. when a new Protocol Buffers message should be\nconstructed from scratch, an empty buffer can be created:  pb_buffer_t   buffer   =   pb_buffer_create_empty ();", 
            "title": "Creating an empty buffer"
        }, 
        {
            "location": "/guide/buffers-and-journals/#freeing-a-buffer", 
            "text": "When finished working with the underlying message, the buffer must be\ndestroyed explicitly, so the internally allocated space can be freed:  pb_buffer_destroy ( buffer );   Zero-copy buffers should also always be destroyed for reasons of consistency,\neven if, at the time of writing, no internal allocations are taking place, as\nthis may be subject to change in the future.", 
            "title": "Freeing a buffer"
        }, 
        {
            "location": "/guide/buffers-and-journals/#error-handling", 
            "text": "Afar from zero-copy buffers, creation of regular buffers can theoretically\nfail due to an out-of-memory condition ( ENOMEM ). protobluff is designed to\nfully recover from such conditions, passing the error back to the caller after\ncleaning up any prior allocations. For this reason, the caller should always\nvalidate whether buffer creation was successful:  pb_buffer_t   buffer   =   pb_buffer_create_empty ();  if   ( ! pb_buffer_valid ( buffer )) \n   fprintf ( stderr ,   Error: %s ,   pb_error_string ( pb_buffer_error ( buffer )));   If the caller doesn't validate the buffer after creation and the buffer is\nnot valid, all subsequent calls on messages, cursors and fields will return\nerrors (see the section on  error handling  for more\ndetails).", 
            "title": "Error handling"
        }, 
        {
            "location": "/guide/buffers-and-journals/#accessors", 
            "text": "The buffer may not be altered directly, only by invoking the generated Protocol\nBuffer message accessors or the low-level interface. The raw data and size\nunderlying the buffer can be extracted with the following methods at any time:  const   uint8_t   * data   =   pb_buffer_data ( buffer );  const   size_t     size   =   pb_buffer_size ( buffer );", 
            "title": "Accessors"
        }, 
        {
            "location": "/guide/buffers-and-journals/#custom-allocators", 
            "text": "protobluff is designed to allow  custom allocator \nimplementations, facilitating a more fine grained control of how memory is\nlayed out. The default allocator is just a wrapper around the POSIX functions malloc ,  realloc  and  free . Alternative implementations may yield better\nperformance in specific cases, like chunk allocators or fixed-size allocators.\nA buffer can be easily created together with a custom allocator:  pb_buffer_t   buffer   =   pb_buffer_create_with_allocator ( allocator ,   data ,   size );   The same holds for an empty buffer:  pb_buffer_t   buffer   =   pb_buffer_create_empty_with_allocator ( allocator );   For guidance on this topic, see the documentation on custom allocators .", 
            "title": "Custom allocators"
        }, 
        {
            "location": "/guide/messages/", 
            "text": "Overview\n\n\nAs Protocol Buffers is a data interchange format, messages and message types\nare at the very core of protobluff. Message types are logically grouped\ntogether and described in a \n.proto\n schema file in a language-neutral format.\nFrom this schema file, protobluff generates bindings for the C language, so\nthat wire-encoded messages of the respective type can be easily processed,\nomitting the necessity for manual parsing like it is with schema-less message\nformats. However, protobluff does not generate structs from Protocol Buffers\ndefinitions like most of the implementations for the C language do, but rather\ndescriptors that are used to dynamically alter messages.\n\n\nDefining a message type\n\n\nProtocol Buffers message definitions are written in a declarative language.\nFor further explanations, we'll use the basic example from the\n\nProtocol Buffers Developer Guide\n that defines a simple message with information about a person in a file\ncalled \nperson.proto\n:\n\n\nmessage\n \nPerson\n \n{\n\n  \nmessage\n \nPhoneNumber\n \n{\n\n    \nenum\n \nPhoneType\n \n{\n\n      \nMOBILE\n \n=\n \n0\n;\n\n      \nHOME\n \n=\n \n1\n;\n\n      \nWORK\n \n=\n \n2\n;\n\n    \n}\n\n    \nrequired\n \nstring\n \nnumber\n \n=\n \n1\n;\n\n    \noptional\n \nPhoneType\n \ntype\n \n=\n \n2\n \n[\ndefault\n \n=\n \nHOME\n];\n\n  \n}\n\n  \nrequired\n \nstring\n \nname\n \n=\n \n1\n;\n\n  \nrequired\n \nint32\n \nid\n \n=\n \n2\n;\n\n  \noptional\n \nstring\n \nemail\n \n=\n \n3\n;\n\n  \nrepeated\n \nPhoneNumber\n \nphone\n \n=\n \n4\n;\n\n\n}\n\n\n\n\n\nAfter defining the message type, the required bindings must be generated. The\ncode generator can be invoked with the following command:\n\n\nprotoc --protobluff_out\n=\n. person.proto\n\n\n\n\nThis will generate two files, namely \nperson.pb.h\n and \nperson.pb.c\n in the\ndirectory specified for the \n--protobluff_out\n flag. The header file must be\nincluded in the parts of the application where the bindings are used, the\nsource file must be compiled with the application. Furthermore, the protobluff\nruntime must be linked against the application. See the notes on\n\nchoosing a runtime\n for further details on how\nto link protobluff.\n\n\nThe resulting bindings in \nperson.pb.h\n will contain bindings for the lite and\nfull runtime that are defined as inline functions using the low-level interface\nand look like this (excerpt):\n\n\n...\n\n\n/* Person : create */\n\n\nPB_WARN_UNUSED_RESULT\n\n\nPB_INLINE\n \npb_message_t\n\n\nperson_create\n(\npb_journal_t\n \n*\njournal\n)\n \n{\n\n  \nreturn\n \npb_message_create\n(\nperson_descriptor\n,\n \njournal\n);\n\n\n}\n\n\n\n/* Person : destroy */\n\n\nPB_INLINE\n \nvoid\n\n\nperson_destroy\n(\npb_message_t\n \n*\nmessage\n)\n \n{\n\n  \nassert\n(\npb_message_descriptor\n(\nmessage\n)\n \n==\n \nperson_descriptor\n);\n\n  \nreturn\n \npb_message_destroy\n(\nmessage\n);\n\n\n}\n\n\n\n/* Person.name : get */\n\n\nPB_WARN_UNUSED_RESULT\n\n\nPB_INLINE\n \npb_error_t\n\n\nperson_get_name\n(\npb_message_t\n \n*\nmessage\n,\n \npb_string_t\n \n*\nvalue\n)\n \n{\n\n  \nassert\n(\npb_message_descriptor\n(\nmessage\n)\n \n==\n \nperson_descriptor\n);\n\n  \nreturn\n \npb_message_get\n(\nmessage\n,\n \n1\n,\n \nvalue\n);\n\n\n}\n\n\n\n/* Person.name : put */\n\n\nPB_WARN_UNUSED_RESULT\n\n\nPB_INLINE\n \npb_error_t\n\n\nperson_put_name\n(\npb_message_t\n \n*\nmessage\n,\n \nconst\n \npb_string_t\n \n*\nvalue\n)\n \n{\n\n  \nassert\n(\npb_message_descriptor\n(\nmessage\n)\n \n==\n \nperson_descriptor\n);\n\n  \nreturn\n \npb_message_put\n(\nmessage\n,\n \n1\n,\n \nvalue\n);\n\n\n}\n\n\n...\n\n\n\n\n\nWhy inline functions? Because there's no overhead when compiling the program,\nas all function calls are only thin wrappers around the low-level interface of\nprotobluff. While in development mode descriptors are checked with assertions\nfor the correct type, code for production should be compiled with the flag\n\n-DNDEBUG\n, which will remove all assertions.\n\n\nCreating a message\n\n\nUsing the full runtime, a message can easily be created with a valid journal:\n\n\npb_message_t\n \nperson\n \n=\n \nperson_create\n(\njournal\n);\n\n\nif\n \n(\n!\npb_message_valid\n(\nperson\n))\n \n{\n\n  \n/* Error creating person message */\n\n\n}\n\n\n\n\n\nReading from a message\n\n\nTo read the value of a field, the generated accessors can be used:\n\n\npb_string_t\n \nname\n;\n\n\nif\n \n(\nperson_get_name\n(\nperson\n,\n \nname\n))\n \n{\n\n  \n/* Error reading name from person message */\n\n\n}\n\n\n\n\n\nReading values from a message is only allowed for non-repeated scalar types.\nMessages need to be accessed through \npb_message_create_within\n, repeated\nfields must be accessed through cursors \u2013 see the documentation on\n\nrepeated fields\n for more information.\n\n\nIf the message doesn't contain a value for the respective field and no\ndefault value is set, the function will return \nPB_ERROR_ABSENT\n.\n\n\nWriting to a message\n\n\nWriting a value to a field is equally straight forward:\n\n\npb_string_t\n \nname\n \n=\n \npb_string_init\n(\nJohn Doe\n);\n\n\nif\n \n(\nperson_put_name\n(\nperson\n,\n \nname\n))\n \n{\n\n  \n/* Error writing name to person message */\n\n\n}\n\n\n\n\n\nWriting a value or submessage to a message is translated into a low-level call\nof \npb_message_put\n which allows all Protocol Buffer types to be written.\nHowever, writing a repeated field or submessage will always create (append) a\nnew instance. If a specific instance should be updated, cursors must be used.\nAgain, see the documentation on \nrepeated fields\n for\nmore information.\n\n\nErasing from a message\n\n\nErasing a field can be done with:\n\n\nif\n \n(\nperson_erase_name\n(\nperson\n))\n \n{\n\n  \n/* Error erasing name from person message */\n\n\n}\n\n\n\n\n\nErasing a field or submessage from a message is an idempotent operation,\nregardless of whether the field existed or not. Erasing a repeated field or\nsubmessage will always erase \nall occurrences\n. In order to erase specific\noccurrences of a field, a cursor must be used.\n\n\nFreeing a message\n\n\nBurn after reading -- though messages don't perform any dynamic allocations,\nit is recommended to destroy them after use:\n\n\nperson_destroy\n(\nperson\n);\n\n\n\n\n\nThis will keep your application future-proof.\n\n\nDumping a message\n\n\nFor debugging purposes, messages can be dumped to inspect the underlying wire\nformat:\n\n\npb_message_dump\n(\nperson\n);\n\n\n\n\n\nThis will write something like the following to the terminal, denoting the\ncontent and offsets of a message within the context of other messages:\n\n\n   0  offset start\n  73  offset end\n  73  length\n----  ---------------------------------------  -------------------\n   0   10   8  74 111 104 110  32  68 111 101  . . J o h n   D o e\n  10   16 210   9  26  16 106 100 111 101  64  . . . . . j d o e @\n  20  101 120  97 109 112 108 101  46  99 111  e x a m p l e . c o\n  30  109  34  19  10  15  43  49  45  53  52  m \n . . . + 1 - 5 4\n  40   49  45  55  53  52  45  51  48  49  48  1 - 7 5 4 - 3 0 1 0\n  50   16   1  34  19  10  15  43  49  45  53  . . \n . . . + 1 - 5\n  60   52  49  45  50  57  51  45  56  50  50  4 1 - 2 9 3 - 8 2 2\n  70   56  16   0                              8 . .\n\n\n\n\nError handling\n\n\nAll functions and macros that create new structures or alter the contents of\nmessages and return the type \npb_error_t\n should be checked for errors. See\nthe section on \nerror handling\n for a detailed\ndescription and semantics of all possible errors.", 
            "title": "Working with messages"
        }, 
        {
            "location": "/guide/messages/#overview", 
            "text": "As Protocol Buffers is a data interchange format, messages and message types\nare at the very core of protobluff. Message types are logically grouped\ntogether and described in a  .proto  schema file in a language-neutral format.\nFrom this schema file, protobluff generates bindings for the C language, so\nthat wire-encoded messages of the respective type can be easily processed,\nomitting the necessity for manual parsing like it is with schema-less message\nformats. However, protobluff does not generate structs from Protocol Buffers\ndefinitions like most of the implementations for the C language do, but rather\ndescriptors that are used to dynamically alter messages.", 
            "title": "Overview"
        }, 
        {
            "location": "/guide/messages/#defining-a-message-type", 
            "text": "Protocol Buffers message definitions are written in a declarative language.\nFor further explanations, we'll use the basic example from the Protocol Buffers Developer Guide  that defines a simple message with information about a person in a file\ncalled  person.proto :  message   Person   { \n   message   PhoneNumber   { \n     enum   PhoneType   { \n       MOBILE   =   0 ; \n       HOME   =   1 ; \n       WORK   =   2 ; \n     } \n     required   string   number   =   1 ; \n     optional   PhoneType   type   =   2   [ default   =   HOME ]; \n   } \n   required   string   name   =   1 ; \n   required   int32   id   =   2 ; \n   optional   string   email   =   3 ; \n   repeated   PhoneNumber   phone   =   4 ;  }   After defining the message type, the required bindings must be generated. The\ncode generator can be invoked with the following command:  protoc --protobluff_out = . person.proto  This will generate two files, namely  person.pb.h  and  person.pb.c  in the\ndirectory specified for the  --protobluff_out  flag. The header file must be\nincluded in the parts of the application where the bindings are used, the\nsource file must be compiled with the application. Furthermore, the protobluff\nruntime must be linked against the application. See the notes on choosing a runtime  for further details on how\nto link protobluff.  The resulting bindings in  person.pb.h  will contain bindings for the lite and\nfull runtime that are defined as inline functions using the low-level interface\nand look like this (excerpt):  ...  /* Person : create */  PB_WARN_UNUSED_RESULT  PB_INLINE   pb_message_t  person_create ( pb_journal_t   * journal )   { \n   return   pb_message_create ( person_descriptor ,   journal );  }  /* Person : destroy */  PB_INLINE   void  person_destroy ( pb_message_t   * message )   { \n   assert ( pb_message_descriptor ( message )   ==   person_descriptor ); \n   return   pb_message_destroy ( message );  }  /* Person.name : get */  PB_WARN_UNUSED_RESULT  PB_INLINE   pb_error_t  person_get_name ( pb_message_t   * message ,   pb_string_t   * value )   { \n   assert ( pb_message_descriptor ( message )   ==   person_descriptor ); \n   return   pb_message_get ( message ,   1 ,   value );  }  /* Person.name : put */  PB_WARN_UNUSED_RESULT  PB_INLINE   pb_error_t  person_put_name ( pb_message_t   * message ,   const   pb_string_t   * value )   { \n   assert ( pb_message_descriptor ( message )   ==   person_descriptor ); \n   return   pb_message_put ( message ,   1 ,   value );  }  ...   Why inline functions? Because there's no overhead when compiling the program,\nas all function calls are only thin wrappers around the low-level interface of\nprotobluff. While in development mode descriptors are checked with assertions\nfor the correct type, code for production should be compiled with the flag -DNDEBUG , which will remove all assertions.", 
            "title": "Defining a message type"
        }, 
        {
            "location": "/guide/messages/#creating-a-message", 
            "text": "Using the full runtime, a message can easily be created with a valid journal:  pb_message_t   person   =   person_create ( journal );  if   ( ! pb_message_valid ( person ))   { \n   /* Error creating person message */  }", 
            "title": "Creating a message"
        }, 
        {
            "location": "/guide/messages/#reading-from-a-message", 
            "text": "To read the value of a field, the generated accessors can be used:  pb_string_t   name ;  if   ( person_get_name ( person ,   name ))   { \n   /* Error reading name from person message */  }   Reading values from a message is only allowed for non-repeated scalar types.\nMessages need to be accessed through  pb_message_create_within , repeated\nfields must be accessed through cursors \u2013 see the documentation on repeated fields  for more information.  If the message doesn't contain a value for the respective field and no\ndefault value is set, the function will return  PB_ERROR_ABSENT .", 
            "title": "Reading from a message"
        }, 
        {
            "location": "/guide/messages/#writing-to-a-message", 
            "text": "Writing a value to a field is equally straight forward:  pb_string_t   name   =   pb_string_init ( John Doe );  if   ( person_put_name ( person ,   name ))   { \n   /* Error writing name to person message */  }   Writing a value or submessage to a message is translated into a low-level call\nof  pb_message_put  which allows all Protocol Buffer types to be written.\nHowever, writing a repeated field or submessage will always create (append) a\nnew instance. If a specific instance should be updated, cursors must be used.\nAgain, see the documentation on  repeated fields  for\nmore information.", 
            "title": "Writing to a message"
        }, 
        {
            "location": "/guide/messages/#erasing-from-a-message", 
            "text": "Erasing a field can be done with:  if   ( person_erase_name ( person ))   { \n   /* Error erasing name from person message */  }   Erasing a field or submessage from a message is an idempotent operation,\nregardless of whether the field existed or not. Erasing a repeated field or\nsubmessage will always erase  all occurrences . In order to erase specific\noccurrences of a field, a cursor must be used.", 
            "title": "Erasing from a message"
        }, 
        {
            "location": "/guide/messages/#freeing-a-message", 
            "text": "Burn after reading -- though messages don't perform any dynamic allocations,\nit is recommended to destroy them after use:  person_destroy ( person );   This will keep your application future-proof.", 
            "title": "Freeing a message"
        }, 
        {
            "location": "/guide/messages/#dumping-a-message", 
            "text": "For debugging purposes, messages can be dumped to inspect the underlying wire\nformat:  pb_message_dump ( person );   This will write something like the following to the terminal, denoting the\ncontent and offsets of a message within the context of other messages:     0  offset start\n  73  offset end\n  73  length\n----  ---------------------------------------  -------------------\n   0   10   8  74 111 104 110  32  68 111 101  . . J o h n   D o e\n  10   16 210   9  26  16 106 100 111 101  64  . . . . . j d o e @\n  20  101 120  97 109 112 108 101  46  99 111  e x a m p l e . c o\n  30  109  34  19  10  15  43  49  45  53  52  m   . . . + 1 - 5 4\n  40   49  45  55  53  52  45  51  48  49  48  1 - 7 5 4 - 3 0 1 0\n  50   16   1  34  19  10  15  43  49  45  53  . .   . . . + 1 - 5\n  60   52  49  45  50  57  51  45  56  50  50  4 1 - 2 9 3 - 8 2 2\n  70   56  16   0                              8 . .", 
            "title": "Dumping a message"
        }, 
        {
            "location": "/guide/messages/#error-handling", 
            "text": "All functions and macros that create new structures or alter the contents of\nmessages and return the type  pb_error_t  should be checked for errors. See\nthe section on  error handling  for a detailed\ndescription and semantics of all possible errors.", 
            "title": "Error handling"
        }, 
        {
            "location": "/guide/scalar-types/", 
            "text": "Overview\n\n\nThe Protocol Buffers specification defines a multitude of signed and unsigned\ninteger types (each with different implications for the underlying wire\nrepresentation), as well as types for the representation of floating point\nnumbers, booleans, bytes and strings.\n\n\nType mappings\n\n\nThe following table shows the type mappings from C types (both native and\ncustom types like \npb_string_t\n) to Protocol Buffer schema types:\n\n\n\n\n\n\n\n\nNative type\n\n\nSchema type\n\n\n\n\n\n\n\n\n\n\nint32_t\n\n\nint32\n, \nsint32\n, \nfixed32\n\n\n\n\n\n\nint64_t\n\n\nint64\n, \nsint64\n, \nfixed64\n\n\n\n\n\n\nuint8_t\n\n\nbool\n\n\n\n\n\n\nuint32_t\n\n\nuint32\n, \nfixed32\n\n\n\n\n\n\nuint64_t\n\n\nuint64\n, \nfixed64\n\n\n\n\n\n\nfloat\n\n\nfloat\n\n\n\n\n\n\ndouble\n\n\ndouble\n\n\n\n\n\n\npb_enum_t\n\n\nenum\n\n\n\n\n\n\npb_string_t\n\n\nbytes\n, \nstring\n\n\n\n\n\n\n\n\nSee the \nProtocol Buffers specification\n for more information on types.\n\n\nStrings and byte arrays\n\n\nWhile the mappings of integer and floating point types should be quite\nself-explanatory, strings are worth discussing: in wire representation, strings\nand byte arrays are stored as a length-prefixed, unterminated list of unsigned\nchars. Because there's no nul-terminator, the length needs to be explicitly\nreturned. This is what the datatype \npb_string_t\n is for. The header file\n\ncore/string.h\n defines a few useful functions for working with strings:\n\n\n/* Initialize a string with explicit length */\n\n\npb_string_t\n \nstring\n \n=\n \npb_string_init\n(\nTEST\n,\n \n4\n);\n\n\n\n/* Initialize a string from a nul-terminated array of unsigned chars */\n\n\npb_string_t\n \nstring\n \n=\n \npb_string_init_from_chars\n(\nTEST\n);\n\n\n\n/* Initialize an empty string - may be useful at times */\n\n\npb_string_t\n \nstring\n \n=\n \npb_string_init_empty\n();\n\n\n\n/* Retrieve the underlying data and size of a string */\n\n\nconst\n \nuint8_t\n \n*\ndata\n \n=\n \npb_string_data\n(\nstring\n);\n\n\nconst\n \nsize_t\n   \nsize\n \n=\n \npb_string_size\n(\nstring\n);\n\n\n\n\n\nStrings are always allocated on the stack and do not take ownership of the\nprovided array of unsigned chars, so there's no need for freeing them, but the\ncaller must ensure that the array is not freed during operations.", 
            "title": "Scalar types"
        }, 
        {
            "location": "/guide/scalar-types/#overview", 
            "text": "The Protocol Buffers specification defines a multitude of signed and unsigned\ninteger types (each with different implications for the underlying wire\nrepresentation), as well as types for the representation of floating point\nnumbers, booleans, bytes and strings.", 
            "title": "Overview"
        }, 
        {
            "location": "/guide/scalar-types/#type-mappings", 
            "text": "The following table shows the type mappings from C types (both native and\ncustom types like  pb_string_t ) to Protocol Buffer schema types:     Native type  Schema type      int32_t  int32 ,  sint32 ,  fixed32    int64_t  int64 ,  sint64 ,  fixed64    uint8_t  bool    uint32_t  uint32 ,  fixed32    uint64_t  uint64 ,  fixed64    float  float    double  double    pb_enum_t  enum    pb_string_t  bytes ,  string     See the  Protocol Buffers specification  for more information on types.", 
            "title": "Type mappings"
        }, 
        {
            "location": "/guide/scalar-types/#strings-and-byte-arrays", 
            "text": "While the mappings of integer and floating point types should be quite\nself-explanatory, strings are worth discussing: in wire representation, strings\nand byte arrays are stored as a length-prefixed, unterminated list of unsigned\nchars. Because there's no nul-terminator, the length needs to be explicitly\nreturned. This is what the datatype  pb_string_t  is for. The header file core/string.h  defines a few useful functions for working with strings:  /* Initialize a string with explicit length */  pb_string_t   string   =   pb_string_init ( TEST ,   4 );  /* Initialize a string from a nul-terminated array of unsigned chars */  pb_string_t   string   =   pb_string_init_from_chars ( TEST );  /* Initialize an empty string - may be useful at times */  pb_string_t   string   =   pb_string_init_empty ();  /* Retrieve the underlying data and size of a string */  const   uint8_t   * data   =   pb_string_data ( string );  const   size_t     size   =   pb_string_size ( string );   Strings are always allocated on the stack and do not take ownership of the\nprovided array of unsigned chars, so there's no need for freeing them, but the\ncaller must ensure that the array is not freed during operations.", 
            "title": "Strings and byte arrays"
        }, 
        {
            "location": "/guide/repeated-fields/", 
            "text": "Overview\n\n\nprotobluff implements the concept of a cursor to access separate instances of a\nrepeated field within an encoded message. Cursors are capable of handling\ntag/value-encoded fields, as well as packed fields very well.\n\n\nThe following explanations on handling repeated fields are based on the example\nmessage type defined in the section on\n\nworking with messages\n.\n\n\nCreating a cursor\n\n\nA cursor over a message for a repeated field can be created as follows:\n\n\npb_cursor_t\n \ncursor\n \n=\n \nperson_create_phone_cursor\n(\nperson\n);\n\n\nif\n \n(\n!\npb_cursor_valid\n(\ncursor\n))\n\n  \n/* Error creating cursor on phone numbers */\n\n\n}\n\n\n\n\n\nThe cursor will always either point to a valid instance of a repeated field or\nbe invalid. If the cursor isn't valid, the cursor may either have encountered\ngarbled data or there is no instance for the repeated field.\n\n\nWorking with a cursor\n\n\nAfter checking if the cursor is valid, the current field may be read, written\nor erased. While scalar types may be directly read and written through the\ncursor, submessages must be created from the cursor in order to work with them.\nErasing a field is independent of its type.\n\n\nSubmessages\n\n\nSubmessages must be created through the function \npb_message_create_from_cursor\n\nwhich will return a message of type \npb_message_t\n:\n\n\npb_cursor_t\n \ncursor\n \n=\n \nperson_create_phone_cursor\n(\nperson\n);\n\n\nif\n \n(\n!\npb_cursor_valid\n(\ncursor\n))\n \n{\n\n  \ndo\n \n{\n\n    \npb_message_t\n \nphone\n \n=\n \npb_message_create_from_cursor\n(\ncursor\n);\n\n    \nif\n \n(\n!\npb_message_valid\n())\n\n      \nbreak\n;\n\n    \n...\n\n    \nperson_phonenumber_destroy\n(\nphone\n);\n\n  \n}\n \nwhile\n \n(\npb_cursor_next\n(\ncursor\n))\n\n\n}\n\n\n\n\n\nThe fields of the message can then be normally accessed as described in the\nsection on \nworking with messages\n. After working with the\nmessage, it must be explicitly destroyed.\n\n\nScalar types\n\n\nScalar types may be accessed through the functions \npb_cursor_get\n,\n\npb_cursor_put\n and \npb_cursor_erase\n, like in the following example:\n\n\npb_cursor_t\n \ncursor\n \n=\n \n...\n\n\nif\n \n(\n!\npb_cursor_valid\n(\ncursor\n))\n \n{\n\n  \npb_error_t\n \nerror\n \n=\n \nPB_ERROR_NONE\n;\n\n\n  \n/* Iterate instances of repeated field */\n\n  \ndo\n \n{\n\n    \nuint32_t\n \nvalue\n;\n\n    \nif\n \n(\nerror\n \n=\n \npb_cursor_get\n(\ncursor\n,\n \nvalue\n)))\n\n      \nbreak\n;\n\n\n    \n/* Erase value if equal to 0 */\n\n    \nif\n \n(\nvalue\n \n==\n \n0\n)\n \n{\n\n      \nerror\n \n=\n \npb_cursor_erase\n(\ncursor\n);\n\n\n    \n/* Otherwise decrement value */\n\n    \n}\n \nelse\n \n{\n    \n      \nvalue\n--\n;\n\n      \nerror\n \n=\n \npb_cursor_put\n(\ncursor\n,\n \nvalue\n);\n\n    \n}\n\n  \n}\n \nwhile\n \n(\n!\nerror\n \n \npb_cursor_next\n(\ncursor\n))\n\n\n}\n\n\n\n\n\nFreeing a cursor\n\n\nLike messages, cursors should always be explicitly destroyed to be\nfuture-proof:\n\n\npb_cursor_destroy\n(\ncursor\n);", 
            "title": "Repeated fields"
        }, 
        {
            "location": "/guide/repeated-fields/#overview", 
            "text": "protobluff implements the concept of a cursor to access separate instances of a\nrepeated field within an encoded message. Cursors are capable of handling\ntag/value-encoded fields, as well as packed fields very well.  The following explanations on handling repeated fields are based on the example\nmessage type defined in the section on working with messages .", 
            "title": "Overview"
        }, 
        {
            "location": "/guide/repeated-fields/#creating-a-cursor", 
            "text": "A cursor over a message for a repeated field can be created as follows:  pb_cursor_t   cursor   =   person_create_phone_cursor ( person );  if   ( ! pb_cursor_valid ( cursor )) \n   /* Error creating cursor on phone numbers */  }   The cursor will always either point to a valid instance of a repeated field or\nbe invalid. If the cursor isn't valid, the cursor may either have encountered\ngarbled data or there is no instance for the repeated field.", 
            "title": "Creating a cursor"
        }, 
        {
            "location": "/guide/repeated-fields/#working-with-a-cursor", 
            "text": "After checking if the cursor is valid, the current field may be read, written\nor erased. While scalar types may be directly read and written through the\ncursor, submessages must be created from the cursor in order to work with them.\nErasing a field is independent of its type.", 
            "title": "Working with a cursor"
        }, 
        {
            "location": "/guide/repeated-fields/#submessages", 
            "text": "Submessages must be created through the function  pb_message_create_from_cursor \nwhich will return a message of type  pb_message_t :  pb_cursor_t   cursor   =   person_create_phone_cursor ( person );  if   ( ! pb_cursor_valid ( cursor ))   { \n   do   { \n     pb_message_t   phone   =   pb_message_create_from_cursor ( cursor ); \n     if   ( ! pb_message_valid ()) \n       break ; \n     ... \n     person_phonenumber_destroy ( phone ); \n   }   while   ( pb_cursor_next ( cursor ))  }   The fields of the message can then be normally accessed as described in the\nsection on  working with messages . After working with the\nmessage, it must be explicitly destroyed.", 
            "title": "Submessages"
        }, 
        {
            "location": "/guide/repeated-fields/#scalar-types", 
            "text": "Scalar types may be accessed through the functions  pb_cursor_get , pb_cursor_put  and  pb_cursor_erase , like in the following example:  pb_cursor_t   cursor   =   ...  if   ( ! pb_cursor_valid ( cursor ))   { \n   pb_error_t   error   =   PB_ERROR_NONE ; \n\n   /* Iterate instances of repeated field */ \n   do   { \n     uint32_t   value ; \n     if   ( error   =   pb_cursor_get ( cursor ,   value ))) \n       break ; \n\n     /* Erase value if equal to 0 */ \n     if   ( value   ==   0 )   { \n       error   =   pb_cursor_erase ( cursor ); \n\n     /* Otherwise decrement value */ \n     }   else   {     \n       value -- ; \n       error   =   pb_cursor_put ( cursor ,   value ); \n     } \n   }   while   ( ! error     pb_cursor_next ( cursor ))  }", 
            "title": "Scalar types"
        }, 
        {
            "location": "/guide/repeated-fields/#freeing-a-cursor", 
            "text": "Like messages, cursors should always be explicitly destroyed to be\nfuture-proof:  pb_cursor_destroy ( cursor );", 
            "title": "Freeing a cursor"
        }, 
        {
            "location": "/guide/error-handling/", 
            "text": "Overview\n\n\nFrom a paranoid point of view, there's a lot that can go wrong when working\nwith Protocol Buffers messages, e.g. allocation errors, buffer underruns or\ngarbled data. For this reason, protobluff is designed to anticipate and catch\nall possible errors and to be very specific about what went wrong.\n\n\nprotobluff will always handle erroneous messages gracefully by design. If a\nbuffer with an allocation error is passed to a message constructor, the message\nwill be flagged invalid. Next, if a field to or from this invalid message is\nwritten or read, the resulting return code will indicate the same. The error\nwill gracefully propagate through all subsequent function calls. However, to\ncatch errors and unexpected behavior, the validity of the created structures\nand return values should always be checked explicitly.\n\n\nErrors are represented through codes defined in the type \npb_error_t\n in the\npublic header file \ncore/common.h\n. For a detailed explanation of the specific\nerror codes see \nthis section\n.\n\n\nErrors in return values\n\n\nAll functions that return the type \npb_error_t\n are meant to be encapsulated\nin conditional clauses. The compiler will be very whiny if this is forgotten,\nthanks to the custom compiler attribute \n__warn_unused_result__\n that is\ndefined for the respective functions if supported by the compiler (Clang and\nGCC have had this for a long time). Though it is not recommended, this\nbehavior can be deactivated by compiling the linking program with the flag\n\n-Wno-unused-result\n.\n\n\nIf the call to a function is successful, \nPB_ERROR_NONE\n is returned which is\nset to the value \n0\n, POSIX-style. All other error codes have values greater\nthan zero. This allows easy checks for error conditions in two levels of\nverbosity. If no further details regarding the error are necessary, checking\nfor errors is as simple as:\n\n\nif\n \n(\npb_validator_check\n(\nvalidator\n,\n \nbuffer\n))\n \n{\n\n  \n/* Nope, there was an error */\n\n\n}\n\n\n\n\n\nWhen more information on the type of the error is needed, the following idiom\nshould be applied:\n\n\npb_error_t\n \nerror\n;\n\n\nif\n \n((\nerror\n \n=\n \npb_validator_check\n(\nvalidator\n,\n \nbuffer\n)))\n \n{\n\n  \n/* Nope, there was an error */\n\n\n}\n\n\n\n\n\nThe function \npb_error_string\n is similar to the POSIX function \nstrerror\n\nthat returns a human-readable representation of an error code:\n\n\nfprintf\n(\nstderr\n,\n \nError: %s\n,\n \npb_error_string\n(\nerror\n));\n\n\n\n\n\nErrors upon creation\n\n\nWhen creating new structures, protobluff makes heavy use of the stack where\npossible to minimize the need for dynamic allocations:\n\n\npb_buffer_t\n \nbuffer\n \n=\n \npb_buffer_create_empty\n();\n\n\n\n\n\nUsually, libraries that use dynamic allocation and return pointers implement\nerror conditions by returning \nNULL\n pointers. However, to get further details\non the type of error an extra argument to receive the type of error would have\nto be passed to the function call or a global variable like \nerrno\n would have\nto be used. As protobluff uses stack allocation wherever possible, a different\napproach has to be taken.\n\n\nFor this reason, errors that happen upon creation are encoded into the\nresulting structure, which has two advantages opposed to passing an argument to\nreceive the error: first, there's no need to pass an error pointer as an extra\nargument. Second, as stated before, the error is encoded into the structure, so\nsubsequent calls on an erroneous structure will fail gracefully, e.g.:\n\n\n/* Allocation fails, therefore buffer is invalid */\n\n\npb_buffer_t\n \nbuffer\n \n=\n \npb_buffer_create_empty\n();\n\n\n\n/* Message is invalid, as it\ns created from an invalid buffer */\n\n\npb_message_t\n \nmessage\n \n=\n \npb_message_create\n(\ndescriptor\n,\n \nbuffer\n);\n\n\n\n/* Write to field is not executed, as message is invalid */\n\n\npb_message_put\n(\nmessage\n,\n \n1\n,\n \nvalue\n);\n\n\n\n\n\nNevertheless, it is highly recommended to check every function that returns a\nnew structure or the type \npb_error_t\n for errors. See the specific sections\nfor more details on how this should be done in the respective cases.\n\n\nError codes\n\n\nPB_ERROR_NONE\n\n\nThe operation was successful. This constant will always yield the value \n0\n.\n\n\nPB_ERROR_ALLOC\n\n\nThe required memory could not be allocated, almost only due to an out-of-memory\ncondition (\nENOMEM\n). This may happen when creating a buffer or implicitly\naltering a buffer by writing to its dedicated message or fields.\n\n\nPB_ERROR_INVALID\n\n\nThe arguments passed to the function were not valid, e.g. passing an invalid\nbuffer to a message constructor or trying to write a value to a message for a\ntag that is not part of the underlying message definition.\n\n\nPB_ERROR_VARINT\n\n\nAn invalid variable-sized integer was encountered, i.e. the corresponding type\nis too small. If this happens, the underlying message is either garbled or the\nmessage definitions may not be in sync. For example, a field was changed from\n\nint32\n to \nint64\n on the encoding side, but forgotten to be updated on the\ndecoding side.\n\n\nPB_ERROR_OFFSET\n\n\nThis error is most likely related to garbled data, e.g. when a length prefix\ndenoted that a message of certain length follows, but the buffer terminated\nunexpectedly.\n\n\nPB_ERROR_ABSENT\n\n\nThis error is returned when trying to read the value of an optional field that\nis not present and the field does not define a default value, or a required\nfield is missing during message validation.\n\n\nPB_ERROR_EOM\n\n\nReturned by \npb_cursor_error\n, when the cursor is past the end of the last\nmatching field occurrence, to indicate that the cursor in not valid anymore.", 
            "title": "Error handling"
        }, 
        {
            "location": "/guide/error-handling/#overview", 
            "text": "From a paranoid point of view, there's a lot that can go wrong when working\nwith Protocol Buffers messages, e.g. allocation errors, buffer underruns or\ngarbled data. For this reason, protobluff is designed to anticipate and catch\nall possible errors and to be very specific about what went wrong.  protobluff will always handle erroneous messages gracefully by design. If a\nbuffer with an allocation error is passed to a message constructor, the message\nwill be flagged invalid. Next, if a field to or from this invalid message is\nwritten or read, the resulting return code will indicate the same. The error\nwill gracefully propagate through all subsequent function calls. However, to\ncatch errors and unexpected behavior, the validity of the created structures\nand return values should always be checked explicitly.  Errors are represented through codes defined in the type  pb_error_t  in the\npublic header file  core/common.h . For a detailed explanation of the specific\nerror codes see  this section .", 
            "title": "Overview"
        }, 
        {
            "location": "/guide/error-handling/#errors-in-return-values", 
            "text": "All functions that return the type  pb_error_t  are meant to be encapsulated\nin conditional clauses. The compiler will be very whiny if this is forgotten,\nthanks to the custom compiler attribute  __warn_unused_result__  that is\ndefined for the respective functions if supported by the compiler (Clang and\nGCC have had this for a long time). Though it is not recommended, this\nbehavior can be deactivated by compiling the linking program with the flag -Wno-unused-result .  If the call to a function is successful,  PB_ERROR_NONE  is returned which is\nset to the value  0 , POSIX-style. All other error codes have values greater\nthan zero. This allows easy checks for error conditions in two levels of\nverbosity. If no further details regarding the error are necessary, checking\nfor errors is as simple as:  if   ( pb_validator_check ( validator ,   buffer ))   { \n   /* Nope, there was an error */  }   When more information on the type of the error is needed, the following idiom\nshould be applied:  pb_error_t   error ;  if   (( error   =   pb_validator_check ( validator ,   buffer )))   { \n   /* Nope, there was an error */  }   The function  pb_error_string  is similar to the POSIX function  strerror \nthat returns a human-readable representation of an error code:  fprintf ( stderr ,   Error: %s ,   pb_error_string ( error ));", 
            "title": "Errors in return values"
        }, 
        {
            "location": "/guide/error-handling/#errors-upon-creation", 
            "text": "When creating new structures, protobluff makes heavy use of the stack where\npossible to minimize the need for dynamic allocations:  pb_buffer_t   buffer   =   pb_buffer_create_empty ();   Usually, libraries that use dynamic allocation and return pointers implement\nerror conditions by returning  NULL  pointers. However, to get further details\non the type of error an extra argument to receive the type of error would have\nto be passed to the function call or a global variable like  errno  would have\nto be used. As protobluff uses stack allocation wherever possible, a different\napproach has to be taken.  For this reason, errors that happen upon creation are encoded into the\nresulting structure, which has two advantages opposed to passing an argument to\nreceive the error: first, there's no need to pass an error pointer as an extra\nargument. Second, as stated before, the error is encoded into the structure, so\nsubsequent calls on an erroneous structure will fail gracefully, e.g.:  /* Allocation fails, therefore buffer is invalid */  pb_buffer_t   buffer   =   pb_buffer_create_empty ();  /* Message is invalid, as it s created from an invalid buffer */  pb_message_t   message   =   pb_message_create ( descriptor ,   buffer );  /* Write to field is not executed, as message is invalid */  pb_message_put ( message ,   1 ,   value );   Nevertheless, it is highly recommended to check every function that returns a\nnew structure or the type  pb_error_t  for errors. See the specific sections\nfor more details on how this should be done in the respective cases.", 
            "title": "Errors upon creation"
        }, 
        {
            "location": "/guide/error-handling/#error-codes", 
            "text": "", 
            "title": "Error codes"
        }, 
        {
            "location": "/guide/error-handling/#pb_error_none", 
            "text": "The operation was successful. This constant will always yield the value  0 .", 
            "title": "PB_ERROR_NONE"
        }, 
        {
            "location": "/guide/error-handling/#pb_error_alloc", 
            "text": "The required memory could not be allocated, almost only due to an out-of-memory\ncondition ( ENOMEM ). This may happen when creating a buffer or implicitly\naltering a buffer by writing to its dedicated message or fields.", 
            "title": "PB_ERROR_ALLOC"
        }, 
        {
            "location": "/guide/error-handling/#pb_error_invalid", 
            "text": "The arguments passed to the function were not valid, e.g. passing an invalid\nbuffer to a message constructor or trying to write a value to a message for a\ntag that is not part of the underlying message definition.", 
            "title": "PB_ERROR_INVALID"
        }, 
        {
            "location": "/guide/error-handling/#pb_error_varint", 
            "text": "An invalid variable-sized integer was encountered, i.e. the corresponding type\nis too small. If this happens, the underlying message is either garbled or the\nmessage definitions may not be in sync. For example, a field was changed from int32  to  int64  on the encoding side, but forgotten to be updated on the\ndecoding side.", 
            "title": "PB_ERROR_VARINT"
        }, 
        {
            "location": "/guide/error-handling/#pb_error_offset", 
            "text": "This error is most likely related to garbled data, e.g. when a length prefix\ndenoted that a message of certain length follows, but the buffer terminated\nunexpectedly.", 
            "title": "PB_ERROR_OFFSET"
        }, 
        {
            "location": "/guide/error-handling/#pb_error_absent", 
            "text": "This error is returned when trying to read the value of an optional field that\nis not present and the field does not define a default value, or a required\nfield is missing during message validation.", 
            "title": "PB_ERROR_ABSENT"
        }, 
        {
            "location": "/guide/error-handling/#pb_error_eom", 
            "text": "Returned by  pb_cursor_error , when the cursor is past the end of the last\nmatching field occurrence, to indicate that the cursor in not valid anymore.", 
            "title": "PB_ERROR_EOM"
        }, 
        {
            "location": "/guide/allocators/", 
            "text": "Interface\n\n\nThe interface for the allocator that needs to be implemented is defined in\n\ncore/allocator.h\n:\n\n\ntypedef\n \nvoid\n \n*\n\n\n(\n*\npb_allocator_alloc_f\n)(\n\n  \nvoid\n \n*\ndata\n,\n                          \n/*!\n Internal allocator data */\n\n  \nsize_t\n \nsize\n);\n                        \n/*!\n Bytes to be allocated */\n\n\n\ntypedef\n \nvoid\n \n*\n\n\n(\n*\npb_allocator_realloc_f\n)(\n\n  \nvoid\n \n*\ndata\n,\n                          \n/*!\n Internal allocator data */\n\n  \nvoid\n \n*\nblock\n,\n                         \n/*!\n Memory block to be resized */\n\n  \nsize_t\n \nsize\n);\n                        \n/*!\n Bytes to be allocated */\n\n\n\ntypedef\n \nvoid\n\n\n(\n*\npb_allocator_free_f\n)(\n\n  \nvoid\n \n*\ndata\n,\n                          \n/*!\n Internal allocator data */\n\n  \nvoid\n \n*\nblock\n);\n                        \n/*!\n Memory block to be freed */\n\n\n\ntypedef\n \nstruct\n \npb_allocator_t\n \n{\n\n  \nstruct\n \n{\n\n    \npb_allocator_alloc_f\n \nalloc\n;\n        \n/*!\n Allocate a memory block */\n\n    \npb_allocator_realloc_f\n \nrealloc\n;\n    \n/*!\n Resize a memory block */\n\n    \npb_allocator_free_f\n \nfree\n;\n          \n/*!\n Free a memory block */\n\n  \n}\n \nproc\n;\n\n  \nvoid\n \n*\ndata\n;\n                          \n/*!\n Internal allocator data */\n\n\n}\n \npb_allocator_t\n;\n\n\n\n\n\nCustom allocators can be used with buffers, journals and encoders.\n\n\nImplementations\n\n\nDefault allocator\n\n\nThe default allocator is globally defined through the variable\n\nallocator_default\n.\n\n\nChunk allocator\n\n\nStarting with protobluff 0.2.2, a chunk allocator implementation is included\nin the full runtime. Memory blocks are stored in pre-allocated chunks to\naccount for later growth by allocating more space than is needed upfront. If\nthe block grows inside the corresponding chunk's capacity, the same block is\nreturned. Otherwise, the chunk is doubled in size to make room for more growth:\n\n\npb_allocator_t\n \nallocator\n \n=\n \npb_allocator_chunk_create\n();\n\n\npb_allocator_t\n \nallocator\n \n=\n \npb_allocator_chunk_create_with_capacity\n(\n1024\n);\n\n\n...\n\n\npb_allocator_chunk_destroy\n(\nallocator\n);", 
            "title": "Custom allocators"
        }, 
        {
            "location": "/guide/allocators/#interface", 
            "text": "The interface for the allocator that needs to be implemented is defined in core/allocator.h :  typedef   void   *  ( * pb_allocator_alloc_f )( \n   void   * data ,                            /*!  Internal allocator data */ \n   size_t   size );                          /*!  Bytes to be allocated */  typedef   void   *  ( * pb_allocator_realloc_f )( \n   void   * data ,                            /*!  Internal allocator data */ \n   void   * block ,                           /*!  Memory block to be resized */ \n   size_t   size );                          /*!  Bytes to be allocated */  typedef   void  ( * pb_allocator_free_f )( \n   void   * data ,                            /*!  Internal allocator data */ \n   void   * block );                          /*!  Memory block to be freed */  typedef   struct   pb_allocator_t   { \n   struct   { \n     pb_allocator_alloc_f   alloc ;          /*!  Allocate a memory block */ \n     pb_allocator_realloc_f   realloc ;      /*!  Resize a memory block */ \n     pb_allocator_free_f   free ;            /*!  Free a memory block */ \n   }   proc ; \n   void   * data ;                            /*!  Internal allocator data */  }   pb_allocator_t ;   Custom allocators can be used with buffers, journals and encoders.", 
            "title": "Interface"
        }, 
        {
            "location": "/guide/allocators/#implementations", 
            "text": "", 
            "title": "Implementations"
        }, 
        {
            "location": "/guide/allocators/#default-allocator", 
            "text": "The default allocator is globally defined through the variable allocator_default .", 
            "title": "Default allocator"
        }, 
        {
            "location": "/guide/allocators/#chunk-allocator", 
            "text": "Starting with protobluff 0.2.2, a chunk allocator implementation is included\nin the full runtime. Memory blocks are stored in pre-allocated chunks to\naccount for later growth by allocating more space than is needed upfront. If\nthe block grows inside the corresponding chunk's capacity, the same block is\nreturned. Otherwise, the chunk is doubled in size to make room for more growth:  pb_allocator_t   allocator   =   pb_allocator_chunk_create ();  pb_allocator_t   allocator   =   pb_allocator_chunk_create_with_capacity ( 1024 );  ...  pb_allocator_chunk_destroy ( allocator );", 
            "title": "Chunk allocator"
        }, 
        {
            "location": "/guide/miscellaneous/", 
            "text": "Overview\n\n\nThe following document discusses some proto2 features, that don't have a huge\nimpact on message handling.\n\n\nOneofs\n\n\nprotobluff is capable of handling oneofs. It is even designed to handle oneofs\nin some edge cases, like merged messages, where multiple instances of a oneof\nmay occur. When setting a field that is part of a oneof, protobluff ensures\nthat the field is not overshadowed by a later instance by traversing the cursor\nto the end and erasing all members of the oneof.\n\n\nFurthermore, for each oneof, the code generator will create a function to\ndetermine which member of a oneof is currently active. This function returns\na tag number and can be used inside a \nswitch\n statement.\n\n\nExtensions\n\n\nExtensions are implemented as a linked list of descriptors. They may be defined\nin file or message scope (the latter are known as nested extensions). The\ncode generator will infix extensions with \n_X_\n, in order to avoid name clashes\nwith existing fields. Extensions are initialized automatically upon start up\nof the program through constructor attributes.\n\n\nPackages\n\n\nIf a \n.proto\n file defines a package, the name of the package is prefixed to\nall variables and functions defined inside that file. This is especially useful\nto avoid name clashes between packages.\n\n\nDeprecations\n\n\nInside a \n.proto\n schema file, fields, messages, enums and enum values can be\nannotated with the \ndeprecated\n option. protobluff will flag all functions that\naccess the annotated structure with \nPB_DEPRECATED\n, a compiler attribute to\nsignal deprecated access. This will trigger warnings during compilation without\nany runtime penalty.", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/guide/miscellaneous/#overview", 
            "text": "The following document discusses some proto2 features, that don't have a huge\nimpact on message handling.", 
            "title": "Overview"
        }, 
        {
            "location": "/guide/miscellaneous/#oneofs", 
            "text": "protobluff is capable of handling oneofs. It is even designed to handle oneofs\nin some edge cases, like merged messages, where multiple instances of a oneof\nmay occur. When setting a field that is part of a oneof, protobluff ensures\nthat the field is not overshadowed by a later instance by traversing the cursor\nto the end and erasing all members of the oneof.  Furthermore, for each oneof, the code generator will create a function to\ndetermine which member of a oneof is currently active. This function returns\na tag number and can be used inside a  switch  statement.", 
            "title": "Oneofs"
        }, 
        {
            "location": "/guide/miscellaneous/#extensions", 
            "text": "Extensions are implemented as a linked list of descriptors. They may be defined\nin file or message scope (the latter are known as nested extensions). The\ncode generator will infix extensions with  _X_ , in order to avoid name clashes\nwith existing fields. Extensions are initialized automatically upon start up\nof the program through constructor attributes.", 
            "title": "Extensions"
        }, 
        {
            "location": "/guide/miscellaneous/#packages", 
            "text": "If a  .proto  file defines a package, the name of the package is prefixed to\nall variables and functions defined inside that file. This is especially useful\nto avoid name clashes between packages.", 
            "title": "Packages"
        }, 
        {
            "location": "/guide/miscellaneous/#deprecations", 
            "text": "Inside a  .proto  schema file, fields, messages, enums and enum values can be\nannotated with the  deprecated  option. protobluff will flag all functions that\naccess the annotated structure with  PB_DEPRECATED , a compiler attribute to\nsignal deprecated access. This will trigger warnings during compilation without\nany runtime penalty.", 
            "title": "Deprecations"
        }
    ]
}